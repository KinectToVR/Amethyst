<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Captions.Filters.Explanations.EKF.Text" xml:space="preserve">
    <value>Höchste Latenz, aber sehr flüssig. Es entfernt jeglichen Jitter (Flackern) und reagiert auf schnelle
Bewegungen flink, da es vorhersagefähig (prädiktiv) ist.</value>
  </data>
  <data name="Captions.Filters.Explanations.LERP.Text" xml:space="preserve">
    <value>Minimale Latenz, lässt alle Bewegungen schneller erscheinen als das, wozu der Sensor in der Lage ist. 
Jitter (Flackern) ist bemerkbar.</value>
  </data>
  <data name="Captions.Filters.Explanations.LowPass.Text" xml:space="preserve">
    <value>Latenz ist leicht bemerkbar, entfernt jedoch Jitter (Flackern) und sieht insgesamt flüssiger aus als kein Filter.</value>
  </data>
  <data name="Captions.Filters.Explanations.None.Text" xml:space="preserve">
    <value>Rohe 30hz-Ausgabe vom Sensor.</value>
  </data>
  <data name="Captions.Filters.Names.EKF.Text" xml:space="preserve">
    <value>- Erweiterter Kalman-Filter</value>
  </data>
  <data name="Captions.Filters.Names.LERP.Text" xml:space="preserve">
    <value>- Lineare Interpolation (standardmäßig eingestellt)</value>
  </data>
  <data name="Captions.Filters.Names.LowPass.Text" xml:space="preserve">
    <value>- Low Pass (Tiefpass) Filter</value>
  </data>
  <data name="Captions.Filters.Names.None.Text" xml:space="preserve">
    <value>- Filter ausschalten</value>
  </data>
  <data name="Captions.ManageTrackers.Text" xml:space="preserve">
    <value>Wenn eine Reihe von Trackern aktiviert oder deaktiviert wird, werden sie sofort gespawnt oder despawnt.
Sie werden aber weiterhin in der Liste der Geräten in SteamVR aufgelistet.
Tracker, die gerade deaktiviert wurden, werden bis SteamVR neu gestartet wird als deaktiviert angezeigt.
Sollten Probleme mit der Tracking-Erkennung in Apps auftreten, sollte SteamVR zuerst neu gestartet werden.</value>
  </data>
  <data name="Captions.Orientation.Explanations.Default.Text" xml:space="preserve">
    <value>Diese Einstellung kann für einige Benutzer auf Xbox One Kinect instabil sein.
In diesem Falle, versuche es noch einmal mit der Softwareberechneten Rotation.
Dies ist die Gelenkausrichtung, die vom Kinect SDK basierend auf der Position jedes Gelenks in der Kette approximiert wird.
Stell dir das soweit vor, dass man auf jedes Glied des Körpers Pfeile anknüpft, die auf die Extremitäten zeigen.
Bei Fußtrackern unterscheidet sich das Verhalten zwischen Kinect-Modellen.
Auf Xbox One basiert sich die Drehung auf der Fußspitze, was bedeutet, dass sich Ihre Füße drehen können.
Auf der Xbox 360 basiert die Drehung allein auf dem Knöchel, was bedeutet, dass es keine Fußdrehung gibt.</value>
  </data>
  <data name="Captions.Orientation.Explanations.HMD.Text" xml:space="preserve">
    <value>Die Tracker folgen der Richtung, in die das Headset auf der Y-Achse zeigt. Die Tracker drehen sich aber nicht auf den anderen beiden Achsen.</value>
  </data>
  <data name="Captions.Orientation.Explanations.MathBased.Text" xml:space="preserve">
    <value>Diese Option ist nur für Fußtracker verfügbar.
Die Richtung der Füße wird aus dem Winkel zwischen Knöchel und Fußspitze berechnet.
Die Reichweite wird auf 50% reduziert um Jitter (Flimmern) zu vermeiden. Dies ermöglicht die Drehung der Füße auf der Xbox 360 Kinect.</value>
  </data>
  <data name="Captions.Orientation.Explanations.None.Text" xml:space="preserve">
    <value>Die Tracker drehen sich nur, wenn die Tracker-Spiegelung (Flip) durch Wegschauen aktiviert wird.</value>
  </data>
  <data name="Captions.Orientation.Introduction.Text" xml:space="preserve">
    <value>Alle Rotationseinstellungen werden weiterhin von der Tracker-Spiegelung (Skelett-Flip) beeinflusst, wenn es aktiviert ist.</value>
  </data>
  <data name="Captions.Orientation.Names.Default.Text" xml:space="preserve">
    <value>- Vom Gerät abgeleitete Rotation</value>
  </data>
  <data name="Captions.Orientation.Names.HMD.Text" xml:space="preserve">
    <value>- Headset folgen</value>
  </data>
  <data name="Captions.Orientation.Names.MathBased.Text" xml:space="preserve">
    <value>- Softwareberechnete Rotation</value>
  </data>
  <data name="Captions.Orientation.Names.None.Text" xml:space="preserve">
    <value>- Rotation deaktivieren</value>
  </data>
  <data name="Captions.TrackerConfig.Text" xml:space="preserve">
    <value> Amethyst unterstützt bis zu 7 Basistracker. Zusätzliche können über das Zahnradsymbol umgeschaltet werden.
Jeder Tracker oder Reihe von Trackern enthält Einstellungen zum Anpassen der Rotation und Filterung für einzelne Tracker.
Auf diese Weise kann man beispielsweise einen starken Filter für Füße und Taille einstellen, wenn man beabsichtigt, viel zu sitzen und
gleichzeitig eine schnellere Einstellung für die Ellbogen verwenden, damit die Tracker die Hände besser folgen können.</value>
  </data>
  <data name="Captions.TrackerConfigNote.Text" xml:space="preserve">
    <value>Notiz: Einige dieser Einstellungen sind nur bei Verwendung von Kinect relevant.</value>
  </data>
  <data name="Titles.FilterSettings.Text" xml:space="preserve">
    <value>Filtereinstellungen:</value>
  </data>
  <data name="Titles.ManageTrackers.Text" xml:space="preserve">
    <value>Tracker aktivieren und deaktivieren:</value>
  </data>
  <data name="Titles.RotationSettings.Text" xml:space="preserve">
    <value>Rotationseinstellungen:</value>
  </data>
  <data name="Titles.TrackerConfig.Text" xml:space="preserve">
    <value>Über die Tracker-Konfiguration</value>
  </data>
</root>