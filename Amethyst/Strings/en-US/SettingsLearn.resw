<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Captions.Filters.Explanations.EKF.Text" xml:space="preserve">
    <value>Highest latency, but very clean results. All jitter is removed,
fast movement is still responsive because the filter is predictive.</value>
  </data>
  <data name="Captions.Filters.Explanations.LERP.Text" xml:space="preserve">
    <value>Minimal latency, makes all movement appear to be faster than what the sensor is capable of.
Jitter is still noticeable.</value>
  </data>
  <data name="Captions.Filters.Explanations.LowPass.Text" xml:space="preserve">
    <value>Latency is slightly noticeable, but it removes jitter and looks overall smoother than no filter.</value>
  </data>
  <data name="Captions.Filters.Explanations.None.Text" xml:space="preserve">
    <value>Raw 30hz output from the sensor.</value>
  </data>
  <data name="Captions.Filters.Names.EKF.Text" xml:space="preserve">
    <value>- Extended Kalman Filter</value>
  </data>
  <data name="Captions.Filters.Names.LERP.Text" xml:space="preserve">
    <value>- Linear Interpolation (default)</value>
  </data>
  <data name="Captions.Filters.Names.LowPass.Text" xml:space="preserve">
    <value>- Low Pass Filter</value>
  </data>
  <data name="Captions.Filters.Names.None.Text" xml:space="preserve">
    <value>- Disable Filter</value>
  </data>
  <data name="Captions.ManageTrackers.Text" xml:space="preserve">
    <value>When you enable or disable a set of trackers they will be spawned or despawned right away,
but will still exist in the list of devices in SteamVR. 
Trackers you've just disabled will appear turned off until SteamVR is restarted.
If you run into issues with tracker detection in apps, please restart SteamVR first.</value>
  </data>
  <data name="Captions.Orientation.Explanations.Default.Text" xml:space="preserve">
    <value>This setting can be unstable for some users on Xbox One Kinect, try Software-Calculated Rotation
if that's the case. This is the joint orientation guessed by the Kinect SDK based on the position
of each joint in the chain. Imagine if you were to stick arrows on every limb of your body pointing
towards your extremities. For foot trackers, behavior differs between Kinect models.
On Xbox One, the rotation is based on the tip of the foot, which means that your feet can turn.
On Xbox 360, the rotation is based on the ankle alone, meaning there is no foot rotation.</value>
  </data>
  <data name="Captions.Orientation.Explanations.HMD.Text" xml:space="preserve">
    <value>Trackers will follow the direction the headset is facing in the Y axis (turning around)
but won't rotate on the other two axes.</value>
  </data>
  <data name="Captions.Orientation.Explanations.MathBased.Text" xml:space="preserve">
    <value>This option is only available for feet trackers.
The direction of your feet is calculated from the angle between the ankle and the tip of the foot.
And the range is reduced to 50% to avoid jitter. This allows for foot rotation on Xbox 360 Kinect.</value>
  </data>
  <data name="Captions.Orientation.Explanations.None.Text" xml:space="preserve">
    <value>Trackers don't rotate at all, except for when tracker mirroring (flip) is engaged by facing away.</value>
  </data>
  <data name="Captions.Orientation.Introduction.Text" xml:space="preserve">
    <value>All rotation settings are still affected by tracker mirroring (skeleton flip) when it is enabled.</value>
  </data>
  <data name="Captions.Orientation.Names.Default.Text" xml:space="preserve">
    <value>- Device-inferred Rotation</value>
  </data>
  <data name="Captions.Orientation.Names.HMD.Text" xml:space="preserve">
    <value>- Follow Headset</value>
  </data>
  <data name="Captions.Orientation.Names.MathBased.Text" xml:space="preserve">
    <value>- Software-Calculated Rotation</value>
  </data>
  <data name="Captions.Orientation.Names.None.Text" xml:space="preserve">
    <value>- Disable Rotation</value>
  </data>
  <data name="Captions.TrackerConfig.Text" xml:space="preserve">
    <value>Amethyst supports up to 7 emulated trackers at once. By default only 3 are enabled.
Each set contains settings to adjust how rotation and filtering is handled for particular trackers.
This allows you to for example set a strong filter on your feet and waist if you intend on sitting 
down a lot, while also using a faster setting for elbows so they follow your hands more closely.</value>
  </data>
  <data name="Captions.TrackerConfigNote.Text" xml:space="preserve">
    <value>Note: Some of these settings are only relevant when using Kinect.</value>
  </data>
  <data name="Titles.FilterSettings.Text" xml:space="preserve">
    <value>Filter settings:</value>
  </data>
  <data name="Titles.ManageTrackers.Text" xml:space="preserve">
    <value>Enabling and disabling trackers:</value>
  </data>
  <data name="Titles.RotationSettings.Text" xml:space="preserve">
    <value>Rotation settings:</value>
  </data>
  <data name="Titles.TrackerConfig.Text" xml:space="preserve">
    <value>About tracker configuration</value>
  </data>
</root>