<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Captions.Filters.Explanations.EKF.Text" xml:space="preserve">
    <value>Plus grande latence de tous le filtres, mais d'excellents résultats fluides.
Les mouvements rapides restent sensibles vu que le filtre est prédictif.</value>
  </data>
  <data name="Captions.Filters.Explanations.LERP.Text" xml:space="preserve">
    <value>Latence minimale, donne l'impression que le tracking est plus rapide qu'il l'est vraiment.
Les instabilités sont encore visibles.</value>
  </data>
  <data name="Captions.Filters.Explanations.LowPass.Text" xml:space="preserve">
    <value>La latence est un peu visible, mais c'est plus fluide que sans filtre et les instabilités sont cachées.</value>
  </data>
  <data name="Captions.Filters.Explanations.None.Text" xml:space="preserve">
    <value>Le squelette a 30hz directement du capteur.</value>
  </data>
  <data name="Captions.Filters.Names.EKF.Text" xml:space="preserve">
    <value>- Filtre Kalman Étendu</value>
  </data>
  <data name="Captions.Filters.Names.LERP.Text" xml:space="preserve">
    <value>- Interpolation Linéaire (Défaut)</value>
  </data>
  <data name="Captions.Filters.Names.LowPass.Text" xml:space="preserve">
    <value>- Filtre pass-bas</value>
  </data>
  <data name="Captions.Filters.Names.None.Text" xml:space="preserve">
    <value>- Déasctier le filtre</value>
  </data>
  <data name="Captions.ManageTrackers.Text" xml:space="preserve">
    <value>Lorsqu'un tracker est activé ou désactivé, il apparait immédiatement
dans SteamVR. Sauf que lorsque vous désactivez un tracker qui était présent. Il existe encore dans la liste, juste éteint.
Et restera dans cet état jusqu'a ce que vous relanciez SteamVR.</value>
  </data>
  <data name="Captions.Orientation.Explanations.Default.Text" xml:space="preserve">
    <value>Cette option peut être instable pour certains utilisateurs sur la Kinect One. Si c'est le cas, 
essayez avec la rotation calculée logiciel. L'orientation de chaque articulation est inférée par le SDK
de la Kinect basée sur la position de chaque partie du corps. Imaginez qu'une flèche est attachée au bout
de chaque articulation, et que le tracker pointe dans cette direction. Cette option fonctionne différemment
sur Kinect 360 et Kinect One.
Sur la Kinect Xbox One, la rotation est basée sur le bout du pied, donc vous pouvez tourner vos pieds.
Sur la Kinect Xbox 360, elle est basée sur le talon, donc le tracker suit seulement la jambe.</value>
  </data>
  <data name="Captions.Orientation.Explanations.HMD.Text" xml:space="preserve">
    <value>Les trackers suivent l'orientation du casque de VR sur l'axe Y
mais perdent toute rotation dans les deux autres.</value>
  </data>
  <data name="Captions.Orientation.Explanations.MathBased.Text" xml:space="preserve">
    <value>Cette option est disponible seulement pour les pieds.
La direction des pieds est calculée en se basant sur l'orientation du bout des pieds jusqu'au talon.
Le mouvement est limité à 50% pour éviter les glitch. Cette option permet de tourner les pieds sur la Kinect 360.</value>
  </data>
  <data name="Captions.Orientation.Explanations.None.Text" xml:space="preserve">
    <value>Les trackers ne tournent pas. Sauf quand le retournement est actif en étant dos à la Kinect.</value>
  </data>
  <data name="Captions.Orientation.Introduction.Text" xml:space="preserve">
    <value>Toutes les options de rotation sont affectées par le retournement des trackers.</value>
  </data>
  <data name="Captions.Orientation.Names.Default.Text" xml:space="preserve">
    <value>- Rotation inférée par l'appareil</value>
  </data>
  <data name="Captions.Orientation.Names.HMD.Text" xml:space="preserve">
    <value>- Suivre le casque</value>
  </data>
  <data name="Captions.Orientation.Names.MathBased.Text" xml:space="preserve">
    <value>- Rotation calculée logiciel</value>
  </data>
  <data name="Captions.Orientation.Names.None.Text" xml:space="preserve">
    <value>- Désactiver la rotation</value>
  </data>
  <data name="Captions.TrackerConfig.Text" xml:space="preserve">
    <value>Amethyst supporte jusqu'à 7 trackers de base, et des trackers additionels peuvent être
activés ou désactivés en cliquant sur l'icône d'engrenage. Chaque tracker ou ensemble de trackers
a ses propres paramêtres pour configurer comment leur rotation fonctionne et quel filtre est utilisé
pour les mouvements. Ceci vous permet par exemple d'appliquer un filtre plus rapide aux coudes et
un filtre plus prononcé sur les pieds si vous comptez vous asseoir souvent.</value>
  </data>
  <data name="Captions.TrackerConfigNote.Text" xml:space="preserve">
    <value>Note: Certeines de ces options fonctionnent seulement avec Kinect.</value>
  </data>
  <data name="Titles.FilterSettings.Text" xml:space="preserve">
    <value>Paramêtres de filtre:</value>
  </data>
  <data name="Titles.ManageTrackers.Text" xml:space="preserve">
    <value>Activer/désactiver les trackers:</value>
  </data>
  <data name="Titles.RotationSettings.Text" xml:space="preserve">
    <value>Paramêtres de rotation:</value>
  </data>
  <data name="Titles.TrackerConfig.Text" xml:space="preserve">
    <value>À propos de la configuration des trackers</value>
  </data>
</root>