// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Amethyst_API.proto

#include "pch.h"
#include "Amethyst_API.pb.h"
#include "Amethyst_API.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace ktvr
{
	static const char* IK2DriverService_method_names[] = {
		"/ktvr.IK2DriverService/SetTrackerStateVector",
		"/ktvr.IK2DriverService/UpdateTrackerVector",
		"/ktvr.IK2DriverService/RefreshTrackerPoseVector",
		"/ktvr.IK2DriverService/RequestVRRestart",
		"/ktvr.IK2DriverService/SetTrackerStateVectorNoReply",
		"/ktvr.IK2DriverService/UpdateTrackerVectorNoReply",
		"/ktvr.IK2DriverService/RefreshTrackerPoseVectorNoReply",
		"/ktvr.IK2DriverService/RequestVRRestartNoReply",
	};

	std::unique_ptr<IK2DriverService::Stub> IK2DriverService::NewStub(
		const std::shared_ptr<grpc::ChannelInterface>& channel, const
		grpc::StubOptions& options)
	{
		(void)options;
		std::unique_ptr<Stub> stub(new Stub(channel, options));
		return stub;
	}

	IK2DriverService::Stub::Stub(const std::shared_ptr<grpc::ChannelInterface>& channel,
	                             const grpc::StubOptions& options)
		: channel_(channel), rpcmethod_SetTrackerStateVector_(IK2DriverService_method_names[0],
		                                                      options.suffix_for_stats(),
		                                                      grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
		  , rpcmethod_UpdateTrackerVector_(IK2DriverService_method_names[1], options.suffix_for_stats(),
		                                   grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
		  , rpcmethod_RefreshTrackerPoseVector_(IK2DriverService_method_names[2], options.suffix_for_stats(),
		                                        grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
		  , rpcmethod_RequestVRRestart_(IK2DriverService_method_names[3], options.suffix_for_stats(),
		                                grpc::internal::RpcMethod::NORMAL_RPC, channel)
		  , rpcmethod_SetTrackerStateVectorNoReply_(IK2DriverService_method_names[4], options.suffix_for_stats(),
		                                            grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
		  , rpcmethod_UpdateTrackerVectorNoReply_(IK2DriverService_method_names[5], options.suffix_for_stats(),
		                                          grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
		  , rpcmethod_RefreshTrackerPoseVectorNoReply_(IK2DriverService_method_names[6], options.suffix_for_stats(),
		                                               grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
		  , rpcmethod_RequestVRRestartNoReply_(IK2DriverService_method_names[7], options.suffix_for_stats(), grpc::internal::RpcMethod::NORMAL_RPC, channel)
	{
	}

	grpc::ClientWriter<ServiceRequest>* IK2DriverService::Stub::SetTrackerStateVectorRaw(grpc::ClientContext* context,
		K2ResponseMessage* response)
	{
		return grpc::internal::ClientWriterFactory<ServiceRequest>::Create(
			channel_.get(), rpcmethod_SetTrackerStateVector_, context, response);
	}

	void IK2DriverService::Stub::async::SetTrackerStateVector(grpc::ClientContext* context, K2ResponseMessage* response,
	                                                          grpc::ClientWriteReactor<
		                                                          ServiceRequest>* reactor)
	{
		grpc::internal::ClientCallbackWriterFactory<ServiceRequest>::Create(
			stub_->channel_.get(), stub_->rpcmethod_SetTrackerStateVector_, context, response, reactor);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::AsyncSetTrackerStateVectorRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_SetTrackerStateVector_, context, response, true, tag);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::PrepareAsyncSetTrackerStateVectorRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_SetTrackerStateVector_, context, response, false, nullptr);
	}

	grpc::ClientWriter<ServiceRequest>* IK2DriverService::Stub::UpdateTrackerVectorRaw(grpc::ClientContext* context,
		K2ResponseMessage* response)
	{
		return grpc::internal::ClientWriterFactory<ServiceRequest>::Create(
			channel_.get(), rpcmethod_UpdateTrackerVector_, context, response);
	}

	void IK2DriverService::Stub::async::UpdateTrackerVector(grpc::ClientContext* context, K2ResponseMessage* response,
	                                                        grpc::ClientWriteReactor<
		                                                        ServiceRequest>* reactor)
	{
		grpc::internal::ClientCallbackWriterFactory<ServiceRequest>::Create(
			stub_->channel_.get(), stub_->rpcmethod_UpdateTrackerVector_, context, response, reactor);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::AsyncUpdateTrackerVectorRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_UpdateTrackerVector_, context, response, true, tag);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::PrepareAsyncUpdateTrackerVectorRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_UpdateTrackerVector_, context, response, false, nullptr);
	}

	grpc::ClientWriter<ServiceRequest>* IK2DriverService::Stub::RefreshTrackerPoseVectorRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response)
	{
		return grpc::internal::ClientWriterFactory<ServiceRequest>::Create(
			channel_.get(), rpcmethod_RefreshTrackerPoseVector_, context, response);
	}

	void IK2DriverService::Stub::async::RefreshTrackerPoseVector(grpc::ClientContext* context,
	                                                             K2ResponseMessage* response,
	                                                             grpc::ClientWriteReactor<
		                                                             ServiceRequest>* reactor)
	{
		grpc::internal::ClientCallbackWriterFactory<ServiceRequest>::Create(
			stub_->channel_.get(), stub_->rpcmethod_RefreshTrackerPoseVector_, context, response, reactor);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::AsyncRefreshTrackerPoseVectorRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_RefreshTrackerPoseVector_, context, response, true, tag);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::PrepareAsyncRefreshTrackerPoseVectorRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_RefreshTrackerPoseVector_, context, response, false, nullptr);
	}

	grpc::Status IK2DriverService::Stub::RequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
	                                                      K2ResponseMessage* response)
	{
		return ::grpc::internal::BlockingUnaryCall<ServiceRequest, K2ResponseMessage, grpc::protobuf::MessageLite,
		                                           grpc::protobuf::MessageLite>(
			channel_.get(), rpcmethod_RequestVRRestart_, context, request, response);
	}

	void IK2DriverService::Stub::async::RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
	                                                     K2ResponseMessage* response,
	                                                     std::function<void(grpc::Status)> f)
	{
		::grpc::internal::CallbackUnaryCall<ServiceRequest, K2ResponseMessage, grpc::protobuf::MessageLite,
		                                    grpc::protobuf::MessageLite>(
			stub_->channel_.get(), stub_->rpcmethod_RequestVRRestart_, context, request, response, std::move(f));
	}

	void IK2DriverService::Stub::async::RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
	                                                     K2ResponseMessage* response, grpc::ClientUnaryReactor* reactor)
	{
		grpc::internal::ClientCallbackUnaryFactory::Create<grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
			stub_->channel_.get(), stub_->rpcmethod_RequestVRRestart_, context, request, response, reactor);
	}

	grpc::ClientAsyncResponseReader<K2ResponseMessage>* IK2DriverService::Stub::PrepareAsyncRequestVRRestartRaw(
		grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncResponseReaderHelper::Create<
			K2ResponseMessage, ServiceRequest, grpc::protobuf::MessageLite,
			grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RequestVRRestart_, context, request);
	}

	grpc::ClientAsyncResponseReader<K2ResponseMessage>* IK2DriverService::Stub::AsyncRequestVRRestartRaw(
		grpc::ClientContext* context, const
		ServiceRequest& request, grpc::CompletionQueue* cq)
	{
		auto* result =
			this->PrepareAsyncRequestVRRestartRaw(context, request, cq);
		result->StartCall();
		return result;
	}

	grpc::ClientWriter<ServiceRequest>* IK2DriverService::Stub::SetTrackerStateVectorNoReplyRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response)
	{
		return grpc::internal::ClientWriterFactory<ServiceRequest>::Create(
			channel_.get(), rpcmethod_SetTrackerStateVectorNoReply_, context, response);
	}

	void IK2DriverService::Stub::async::SetTrackerStateVectorNoReply(grpc::ClientContext* context,
	                                                                 K2ResponseMessage* response,
	                                                                 grpc::ClientWriteReactor<
		                                                                 ServiceRequest>* reactor)
	{
		grpc::internal::ClientCallbackWriterFactory<ServiceRequest>::Create(
			stub_->channel_.get(), stub_->rpcmethod_SetTrackerStateVectorNoReply_, context, response, reactor);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::AsyncSetTrackerStateVectorNoReplyRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_SetTrackerStateVectorNoReply_, context, response, true, tag);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::PrepareAsyncSetTrackerStateVectorNoReplyRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_SetTrackerStateVectorNoReply_, context, response, false, nullptr);
	}

	grpc::ClientWriter<ServiceRequest>* IK2DriverService::Stub::UpdateTrackerVectorNoReplyRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response)
	{
		return grpc::internal::ClientWriterFactory<ServiceRequest>::Create(
			channel_.get(), rpcmethod_UpdateTrackerVectorNoReply_, context, response);
	}

	void IK2DriverService::Stub::async::UpdateTrackerVectorNoReply(grpc::ClientContext* context,
	                                                               K2ResponseMessage* response,
	                                                               grpc::ClientWriteReactor<
		                                                               ServiceRequest>* reactor)
	{
		grpc::internal::ClientCallbackWriterFactory<ServiceRequest>::Create(
			stub_->channel_.get(), stub_->rpcmethod_UpdateTrackerVectorNoReply_, context, response, reactor);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::AsyncUpdateTrackerVectorNoReplyRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_UpdateTrackerVectorNoReply_, context, response, true, tag);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::PrepareAsyncUpdateTrackerVectorNoReplyRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_UpdateTrackerVectorNoReply_, context, response, false, nullptr);
	}

	grpc::ClientWriter<ServiceRequest>* IK2DriverService::Stub::RefreshTrackerPoseVectorNoReplyRaw(
		grpc::ClientContext* context,
		K2ResponseMessage* response)
	{
		return grpc::internal::ClientWriterFactory<ServiceRequest>::Create(
			channel_.get(), rpcmethod_RefreshTrackerPoseVectorNoReply_, context, response);
	}

	void IK2DriverService::Stub::async::RefreshTrackerPoseVectorNoReply(grpc::ClientContext* context,
	                                                                    K2ResponseMessage* response,
	                                                                    grpc::ClientWriteReactor<
		                                                                    ServiceRequest>* reactor)
	{
		grpc::internal::ClientCallbackWriterFactory<ServiceRequest>::Create(
			stub_->channel_.get(), stub_->rpcmethod_RefreshTrackerPoseVectorNoReply_, context, response, reactor);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::AsyncRefreshTrackerPoseVectorNoReplyRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_RefreshTrackerPoseVectorNoReply_, context, response, true, tag);
	}

	grpc::ClientAsyncWriter<ServiceRequest>* IK2DriverService::Stub::PrepareAsyncRefreshTrackerPoseVectorNoReplyRaw(
		grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncWriterFactory<ServiceRequest>::Create(
			channel_.get(), cq, rpcmethod_RefreshTrackerPoseVectorNoReply_, context, response, false, nullptr);
	}

	grpc::Status IK2DriverService::Stub::RequestVRRestartNoReply(grpc::ClientContext* context,
	                                                             const ServiceRequest& request,
	                                                             K2ResponseMessage* response)
	{
		return ::grpc::internal::BlockingUnaryCall<ServiceRequest, K2ResponseMessage, grpc::protobuf::MessageLite,
		                                           grpc::protobuf::MessageLite>(
			channel_.get(), rpcmethod_RequestVRRestartNoReply_, context, request, response);
	}

	void IK2DriverService::Stub::async::RequestVRRestartNoReply(grpc::ClientContext* context,
	                                                            const ServiceRequest* request,
	                                                            K2ResponseMessage* response,
	                                                            std::function<void(grpc::Status)> f)
	{
		::grpc::internal::CallbackUnaryCall<ServiceRequest, K2ResponseMessage, grpc::protobuf::MessageLite,
		                                    grpc::protobuf::MessageLite>(
			stub_->channel_.get(), stub_->rpcmethod_RequestVRRestartNoReply_, context, request, response, std::move(f));
	}

	void IK2DriverService::Stub::async::RequestVRRestartNoReply(grpc::ClientContext* context,
	                                                            const ServiceRequest* request,
	                                                            K2ResponseMessage* response,
	                                                            grpc::ClientUnaryReactor* reactor)
	{
		grpc::internal::ClientCallbackUnaryFactory::Create<grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
			stub_->channel_.get(), stub_->rpcmethod_RequestVRRestartNoReply_, context, request, response, reactor);
	}

	grpc::ClientAsyncResponseReader<K2ResponseMessage>* IK2DriverService::Stub::PrepareAsyncRequestVRRestartNoReplyRaw(
		grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
	{
		return grpc::internal::ClientAsyncResponseReaderHelper::Create<
			K2ResponseMessage, ServiceRequest, grpc::protobuf::MessageLite,
			grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RequestVRRestartNoReply_, context, request);
	}

	grpc::ClientAsyncResponseReader<K2ResponseMessage>* IK2DriverService::Stub::AsyncRequestVRRestartNoReplyRaw(
		grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
	{
		auto* result =
			this->PrepareAsyncRequestVRRestartNoReplyRaw(context, request, cq);
		result->StartCall();
		return result;
	}

	IK2DriverService::Service::Service()
	{
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[0],
			grpc::internal::RpcMethod::CLIENT_STREAMING,
			new grpc::internal::ClientStreamingHandler<Service, ServiceRequest, K2ResponseMessage>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   grpc::ServerReader<ServiceRequest>* reader,
				   K2ResponseMessage* resp)
				{
					return service->SetTrackerStateVector(ctx, reader, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[1],
			grpc::internal::RpcMethod::CLIENT_STREAMING,
			new grpc::internal::ClientStreamingHandler<Service, ServiceRequest, K2ResponseMessage>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   grpc::ServerReader<ServiceRequest>* reader,
				   K2ResponseMessage* resp)
				{
					return service->UpdateTrackerVector(ctx, reader, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[2],
			grpc::internal::RpcMethod::CLIENT_STREAMING,
			new grpc::internal::ClientStreamingHandler<Service, ServiceRequest, K2ResponseMessage>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   grpc::ServerReader<ServiceRequest>* reader,
				   K2ResponseMessage* resp)
				{
					return service->RefreshTrackerPoseVector(ctx, reader, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[3],
			grpc::internal::RpcMethod::NORMAL_RPC,
			new grpc::internal::RpcMethodHandler<
				Service, ServiceRequest, K2ResponseMessage, grpc::protobuf::MessageLite,
				grpc::protobuf::MessageLite>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   const ServiceRequest* req,
				   K2ResponseMessage* resp)
				{
					return service->RequestVRRestart(ctx, req, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[4],
			grpc::internal::RpcMethod::CLIENT_STREAMING,
			new grpc::internal::ClientStreamingHandler<Service, ServiceRequest, K2ResponseMessage>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   grpc::ServerReader<ServiceRequest>* reader,
				   K2ResponseMessage* resp)
				{
					return service->SetTrackerStateVectorNoReply(ctx, reader, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[5],
			grpc::internal::RpcMethod::CLIENT_STREAMING,
			new grpc::internal::ClientStreamingHandler<Service, ServiceRequest, K2ResponseMessage>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   grpc::ServerReader<ServiceRequest>* reader,
				   K2ResponseMessage* resp)
				{
					return service->UpdateTrackerVectorNoReply(ctx, reader, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[6],
			grpc::internal::RpcMethod::CLIENT_STREAMING,
			new grpc::internal::ClientStreamingHandler<Service, ServiceRequest, K2ResponseMessage>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   grpc::ServerReader<ServiceRequest>* reader,
				   K2ResponseMessage* resp)
				{
					return service->RefreshTrackerPoseVectorNoReply(ctx, reader, resp);
				}, this)));
		AddMethod(new grpc::internal::RpcServiceMethod(
			IK2DriverService_method_names[7],
			grpc::internal::RpcMethod::NORMAL_RPC,
			new grpc::internal::RpcMethodHandler<
				Service, ServiceRequest, K2ResponseMessage, grpc::protobuf::MessageLite,
				grpc::protobuf::MessageLite>(
				[](Service* service,
				   grpc::ServerContext* ctx,
				   const ServiceRequest* req,
				   K2ResponseMessage* resp)
				{
					return service->RequestVRRestartNoReply(ctx, req, resp);
				}, this)));
	}

	IK2DriverService::Service::~Service()
	{
	}

	grpc::Status IK2DriverService::Service::SetTrackerStateVector(grpc::ServerContext* context, grpc::ServerReader<
		                                                              ServiceRequest>* reader,
	                                                              K2ResponseMessage* response)
	{
		(void)context;
		(void)reader;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::UpdateTrackerVector(grpc::ServerContext* context, grpc::ServerReader<
		                                                            ServiceRequest>* reader,
	                                                            K2ResponseMessage* response)
	{
		(void)context;
		(void)reader;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::RefreshTrackerPoseVector(grpc::ServerContext* context, grpc::ServerReader<
		                                                                 ServiceRequest>* reader,
	                                                                 K2ResponseMessage* response)
	{
		(void)context;
		(void)reader;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::RequestVRRestart(grpc::ServerContext* context,
	                                                         const ServiceRequest* request,
	                                                         K2ResponseMessage* response)
	{
		(void)context;
		(void)request;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::SetTrackerStateVectorNoReply(
		grpc::ServerContext* context, grpc::ServerReader<
			ServiceRequest>* reader, K2ResponseMessage* response)
	{
		(void)context;
		(void)reader;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::UpdateTrackerVectorNoReply(grpc::ServerContext* context, grpc::ServerReader<
		                                                                   ServiceRequest>* reader,
	                                                                   K2ResponseMessage* response)
	{
		(void)context;
		(void)reader;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::RefreshTrackerPoseVectorNoReply(
		grpc::ServerContext* context, grpc::ServerReader<
			ServiceRequest>* reader, K2ResponseMessage* response)
	{
		(void)context;
		(void)reader;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}

	grpc::Status IK2DriverService::Service::RequestVRRestartNoReply(grpc::ServerContext* context,
	                                                                const ServiceRequest* request,
	                                                                K2ResponseMessage* response)
	{
		(void)context;
		(void)request;
		(void)response;
		return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
	}
} // namespace ktvr
