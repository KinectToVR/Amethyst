// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Amethyst_API.proto
#ifndef GRPC_Amethyst_5fAPI_2eproto__INCLUDED
#define GRPC_Amethyst_5fAPI_2eproto__INCLUDED

#include "Amethyst_API.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace ktvr
{
	class KTVR_API IK2DriverService final
	{
	public:
		static constexpr const char* service_full_name()
		{
			return "ktvr.IK2DriverService";
		}

		class StubInterface
		{
		public:
			virtual ~StubInterface()
			{
			}

			std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>> SetTrackerStateVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>>(
					SetTrackerStateVectorRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> AsyncSetTrackerStateVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					AsyncSetTrackerStateVectorRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> PrepareAsyncSetTrackerStateVector(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					PrepareAsyncSetTrackerStateVectorRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>> UpdateTrackerVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>>(
					UpdateTrackerVectorRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> AsyncUpdateTrackerVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					AsyncUpdateTrackerVectorRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> PrepareAsyncUpdateTrackerVector(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					PrepareAsyncUpdateTrackerVectorRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>> RefreshTrackerPoseVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>>(
					RefreshTrackerPoseVectorRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> AsyncRefreshTrackerPoseVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					AsyncRefreshTrackerPoseVectorRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> PrepareAsyncRefreshTrackerPoseVector(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					PrepareAsyncRefreshTrackerPoseVectorRaw(context, response, cq));
			}

			virtual grpc::Status RequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
			                                      K2ResponseMessage* response) = 0;

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>> AsyncRequestVRRestart(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>>(
					AsyncRequestVRRestartRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>> PrepareAsyncRequestVRRestart(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>>(
					PrepareAsyncRequestVRRestartRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>> SetTrackerStateVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>>(
					SetTrackerStateVectorNoReplyRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> AsyncSetTrackerStateVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					AsyncSetTrackerStateVectorNoReplyRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> PrepareAsyncSetTrackerStateVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					PrepareAsyncSetTrackerStateVectorNoReplyRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>> UpdateTrackerVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>>(
					UpdateTrackerVectorNoReplyRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> AsyncUpdateTrackerVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					AsyncUpdateTrackerVectorNoReplyRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> PrepareAsyncUpdateTrackerVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					PrepareAsyncUpdateTrackerVectorNoReplyRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>> RefreshTrackerPoseVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriterInterface<ServiceRequest>>(
					RefreshTrackerPoseVectorNoReplyRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>> AsyncRefreshTrackerPoseVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					AsyncRefreshTrackerPoseVectorNoReplyRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>
			PrepareAsyncRefreshTrackerPoseVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriterInterface<ServiceRequest>>(
					PrepareAsyncRefreshTrackerPoseVectorNoReplyRaw(context, response, cq));
			}

			virtual grpc::Status RequestVRRestartNoReply(grpc::ClientContext* context, const ServiceRequest& request,
			                                             K2ResponseMessage* response) = 0;

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>> AsyncRequestVRRestartNoReply(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>>(
					AsyncRequestVRRestartNoReplyRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>>
			PrepareAsyncRequestVRRestartNoReply(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>>(
					PrepareAsyncRequestVRRestartNoReplyRaw(context, request, cq));
			}

			class async_interface
			{
			public:
				virtual ~async_interface()
				{
				}

				virtual void SetTrackerStateVector(grpc::ClientContext* context, K2ResponseMessage* response,
				                                   grpc::ClientWriteReactor<
					                                   ServiceRequest>* reactor) = 0;
				virtual void UpdateTrackerVector(grpc::ClientContext* context, K2ResponseMessage* response,
				                                 grpc::ClientWriteReactor<
					                                 ServiceRequest>* reactor) = 0;
				virtual void RefreshTrackerPoseVector(grpc::ClientContext* context, K2ResponseMessage* response,
				                                      grpc::ClientWriteReactor<
					                                      ServiceRequest>* reactor) = 0;
				virtual void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                              K2ResponseMessage* response, std::function<void(
					                              grpc::Status)>) = 0;
				virtual void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                              K2ResponseMessage* response,
				                              grpc::ClientUnaryReactor* reactor) = 0;
				virtual void SetTrackerStateVectorNoReply(grpc::ClientContext* context, K2ResponseMessage* response,
				                                          grpc::ClientWriteReactor<
					                                          ServiceRequest>* reactor) = 0;
				virtual void UpdateTrackerVectorNoReply(grpc::ClientContext* context, K2ResponseMessage* response,
				                                        grpc::ClientWriteReactor<
					                                        ServiceRequest>* reactor) = 0;
				virtual void RefreshTrackerPoseVectorNoReply(grpc::ClientContext* context, K2ResponseMessage* response,
				                                             grpc::ClientWriteReactor<
					                                             ServiceRequest>* reactor) = 0;
				virtual void RequestVRRestartNoReply(grpc::ClientContext* context, const ServiceRequest* request,
				                                     K2ResponseMessage* response,
				                                     std::function<void(grpc::Status)>) = 0;
				virtual void RequestVRRestartNoReply(grpc::ClientContext* context, const ServiceRequest* request,
				                                     K2ResponseMessage* response,
				                                     grpc::ClientUnaryReactor* reactor) = 0;
			};

			using experimental_async_interface = class async_interface;
			virtual class async_interface* async() { return nullptr; }
			class async_interface* experimental_async() { return async(); }

		private:
			virtual grpc::ClientWriterInterface<ServiceRequest>* SetTrackerStateVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* AsyncSetTrackerStateVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* PrepareAsyncSetTrackerStateVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientWriterInterface<ServiceRequest>* UpdateTrackerVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* AsyncUpdateTrackerVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* PrepareAsyncUpdateTrackerVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientWriterInterface<ServiceRequest>* RefreshTrackerPoseVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* AsyncRefreshTrackerPoseVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* PrepareAsyncRefreshTrackerPoseVectorRaw(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>* AsyncRequestVRRestartRaw(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>* PrepareAsyncRequestVRRestartRaw(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientWriterInterface<ServiceRequest>* SetTrackerStateVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* AsyncSetTrackerStateVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* PrepareAsyncSetTrackerStateVectorNoReplyRaw(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientWriterInterface<ServiceRequest>* UpdateTrackerVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* AsyncUpdateTrackerVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* PrepareAsyncUpdateTrackerVectorNoReplyRaw(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientWriterInterface<ServiceRequest>* RefreshTrackerPoseVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* AsyncRefreshTrackerPoseVectorNoReplyRaw(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncWriterInterface<ServiceRequest>* PrepareAsyncRefreshTrackerPoseVectorNoReplyRaw(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>* AsyncRequestVRRestartNoReplyRaw(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<K2ResponseMessage>* PrepareAsyncRequestVRRestartNoReplyRaw(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq) = 0;
		};

		class Stub final : public StubInterface
		{
		public:
			Stub(const std::shared_ptr<grpc::ChannelInterface>& channel,
			     const grpc::StubOptions& options = grpc::StubOptions());

			std::unique_ptr<grpc::ClientWriter<ServiceRequest>> SetTrackerStateVector(grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriter<ServiceRequest>>(SetTrackerStateVectorRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> AsyncSetTrackerStateVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					AsyncSetTrackerStateVectorRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> PrepareAsyncSetTrackerStateVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					PrepareAsyncSetTrackerStateVectorRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriter<ServiceRequest>> UpdateTrackerVector(grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriter<ServiceRequest>>(UpdateTrackerVectorRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> AsyncUpdateTrackerVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					AsyncUpdateTrackerVectorRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> PrepareAsyncUpdateTrackerVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					PrepareAsyncUpdateTrackerVectorRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriter<ServiceRequest>> RefreshTrackerPoseVector(grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriter<ServiceRequest>>(
					RefreshTrackerPoseVectorRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> AsyncRefreshTrackerPoseVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					AsyncRefreshTrackerPoseVectorRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> PrepareAsyncRefreshTrackerPoseVector(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					PrepareAsyncRefreshTrackerPoseVectorRaw(context, response, cq));
			}

			grpc::Status RequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
			                              K2ResponseMessage* response) override;

			std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>> AsyncRequestVRRestart(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>>(
					AsyncRequestVRRestartRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>> PrepareAsyncRequestVRRestart(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>>(
					PrepareAsyncRequestVRRestartRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientWriter<ServiceRequest>> SetTrackerStateVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriter<ServiceRequest>>(
					SetTrackerStateVectorNoReplyRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> AsyncSetTrackerStateVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					AsyncSetTrackerStateVectorNoReplyRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> PrepareAsyncSetTrackerStateVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					PrepareAsyncSetTrackerStateVectorNoReplyRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriter<ServiceRequest>> UpdateTrackerVectorNoReply(grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriter<ServiceRequest>>(
					UpdateTrackerVectorNoReplyRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> AsyncUpdateTrackerVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					AsyncUpdateTrackerVectorNoReplyRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> PrepareAsyncUpdateTrackerVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					PrepareAsyncUpdateTrackerVectorNoReplyRaw(context, response, cq));
			}

			std::unique_ptr<grpc::ClientWriter<ServiceRequest>> RefreshTrackerPoseVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response)
			{
				return std::unique_ptr<grpc::ClientWriter<ServiceRequest>>(
					RefreshTrackerPoseVectorNoReplyRaw(context, response));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> AsyncRefreshTrackerPoseVectorNoReply(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					AsyncRefreshTrackerPoseVectorNoReplyRaw(context, response, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>> PrepareAsyncRefreshTrackerPoseVectorNoReply(
				grpc::ClientContext* context, K2ResponseMessage* response, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncWriter<ServiceRequest>>(
					PrepareAsyncRefreshTrackerPoseVectorNoReplyRaw(context, response, cq));
			}

			grpc::Status RequestVRRestartNoReply(grpc::ClientContext* context, const ServiceRequest& request,
			                                     K2ResponseMessage* response) override;

			std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>> AsyncRequestVRRestartNoReply(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>>(
					AsyncRequestVRRestartNoReplyRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>> PrepareAsyncRequestVRRestartNoReply(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<K2ResponseMessage>>(
					PrepareAsyncRequestVRRestartNoReplyRaw(context, request, cq));
			}

			class async final :
				public async_interface
			{
			public:
				void SetTrackerStateVector(grpc::ClientContext* context, K2ResponseMessage* response,
				                           grpc::ClientWriteReactor<
					                           ServiceRequest>* reactor) override;
				void UpdateTrackerVector(grpc::ClientContext* context, K2ResponseMessage* response,
				                         grpc::ClientWriteReactor<
					                         ServiceRequest>* reactor) override;
				void RefreshTrackerPoseVector(grpc::ClientContext* context, K2ResponseMessage* response,
				                              grpc::ClientWriteReactor<
					                              ServiceRequest>* reactor) override;
				void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                      K2ResponseMessage* response, std::function<void(
					                      grpc::Status)>) override;
				void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                      K2ResponseMessage* response,
				                      grpc::ClientUnaryReactor* reactor) override;
				void SetTrackerStateVectorNoReply(grpc::ClientContext* context, K2ResponseMessage* response,
				                                  grpc::ClientWriteReactor<
					                                  ServiceRequest>* reactor) override;
				void UpdateTrackerVectorNoReply(grpc::ClientContext* context, K2ResponseMessage* response,
				                                grpc::ClientWriteReactor<
					                                ServiceRequest>* reactor) override;
				void RefreshTrackerPoseVectorNoReply(grpc::ClientContext* context, K2ResponseMessage* response,
				                                     grpc::ClientWriteReactor<
					                                     ServiceRequest>* reactor) override;
				void RequestVRRestartNoReply(grpc::ClientContext* context, const ServiceRequest* request,
				                             K2ResponseMessage* response, std::function<void(
					                             grpc::Status)>) override;
				void RequestVRRestartNoReply(grpc::ClientContext* context, const ServiceRequest* request,
				                             K2ResponseMessage* response,
				                             grpc::ClientUnaryReactor* reactor) override;

			private:
				friend class Stub;

				explicit async(Stub* stub): stub_(stub)
				{
				}

				Stub* stub() { return stub_; }
				Stub* stub_;
			};

			class async* async() override { return &async_stub_; }

		private:
			std::shared_ptr<grpc::ChannelInterface> channel_;
			class async async_stub_{this};
			grpc::ClientWriter<ServiceRequest>* SetTrackerStateVectorRaw(
				grpc::ClientContext* context, K2ResponseMessage* response) override;
			grpc::ClientAsyncWriter<ServiceRequest>* AsyncSetTrackerStateVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response,
				grpc::CompletionQueue* cq, void* tag) override;
			grpc::ClientAsyncWriter<ServiceRequest>* PrepareAsyncSetTrackerStateVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) override;
			grpc::ClientWriter<ServiceRequest>* UpdateTrackerVectorRaw(grpc::ClientContext* context,
			                                                           K2ResponseMessage* response) override;
			grpc::ClientAsyncWriter<ServiceRequest>* AsyncUpdateTrackerVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response,
				grpc::CompletionQueue* cq, void* tag) override;
			grpc::ClientAsyncWriter<ServiceRequest>* PrepareAsyncUpdateTrackerVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) override;
			grpc::ClientWriter<ServiceRequest>* RefreshTrackerPoseVectorRaw(
				grpc::ClientContext* context, K2ResponseMessage* response) override;
			grpc::ClientAsyncWriter<ServiceRequest>* AsyncRefreshTrackerPoseVectorRaw(grpc::ClientContext* context,
				K2ResponseMessage* response,
				grpc::CompletionQueue* cq, void* tag) override;
			grpc::ClientAsyncWriter<ServiceRequest>* PrepareAsyncRefreshTrackerPoseVectorRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) override;
			grpc::ClientAsyncResponseReader<K2ResponseMessage>* AsyncRequestVRRestartRaw(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq) override;
			grpc::ClientAsyncResponseReader<K2ResponseMessage>* PrepareAsyncRequestVRRestartRaw(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq) override;
			grpc::ClientWriter<ServiceRequest>* SetTrackerStateVectorNoReplyRaw(
				grpc::ClientContext* context, K2ResponseMessage* response) override;
			grpc::ClientAsyncWriter<ServiceRequest>* AsyncSetTrackerStateVectorNoReplyRaw(grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) override;
			grpc::ClientAsyncWriter<ServiceRequest>* PrepareAsyncSetTrackerStateVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) override;
			grpc::ClientWriter<ServiceRequest>* UpdateTrackerVectorNoReplyRaw(
				grpc::ClientContext* context, K2ResponseMessage* response) override;
			grpc::ClientAsyncWriter<ServiceRequest>* AsyncUpdateTrackerVectorNoReplyRaw(grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) override;
			grpc::ClientAsyncWriter<ServiceRequest>* PrepareAsyncUpdateTrackerVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) override;
			grpc::ClientWriter<ServiceRequest>* RefreshTrackerPoseVectorNoReplyRaw(grpc::ClientContext* context,
				K2ResponseMessage* response) override;
			grpc::ClientAsyncWriter<ServiceRequest>* AsyncRefreshTrackerPoseVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq, void* tag) override;
			grpc::ClientAsyncWriter<ServiceRequest>* PrepareAsyncRefreshTrackerPoseVectorNoReplyRaw(
				grpc::ClientContext* context,
				K2ResponseMessage* response, grpc::CompletionQueue* cq) override;
			grpc::ClientAsyncResponseReader<K2ResponseMessage>* AsyncRequestVRRestartNoReplyRaw(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq) override;
			grpc::ClientAsyncResponseReader<K2ResponseMessage>* PrepareAsyncRequestVRRestartNoReplyRaw(
				grpc::ClientContext* context, const
				ServiceRequest& request, grpc::CompletionQueue* cq) override;
			const grpc::internal::RpcMethod rpcmethod_SetTrackerStateVector_;
			const grpc::internal::RpcMethod rpcmethod_UpdateTrackerVector_;
			const grpc::internal::RpcMethod rpcmethod_RefreshTrackerPoseVector_;
			const grpc::internal::RpcMethod rpcmethod_RequestVRRestart_;
			const grpc::internal::RpcMethod rpcmethod_SetTrackerStateVectorNoReply_;
			const grpc::internal::RpcMethod rpcmethod_UpdateTrackerVectorNoReply_;
			const grpc::internal::RpcMethod rpcmethod_RefreshTrackerPoseVectorNoReply_;
			const grpc::internal::RpcMethod rpcmethod_RequestVRRestartNoReply_;
		};

		static std::unique_ptr<Stub> NewStub(const std::shared_ptr<grpc::ChannelInterface>& channel,
		                                     const grpc::StubOptions& options =
			                                     grpc::StubOptions());

		class KTVR_API Service : public grpc::Service
		{
		public:
			Service();
			~Service() override;

			// https://github.com/grpc/grpc/issues/15653
			Service(const Service&) = delete;
			Service& operator = (const Service&) = delete;

			virtual grpc::Status SetTrackerStateVector(grpc::ServerContext* context,
			                                           grpc::ServerReader<ServiceRequest>* reader,
			                                           K2ResponseMessage* response);
			virtual grpc::Status UpdateTrackerVector(grpc::ServerContext* context,
			                                         grpc::ServerReader<ServiceRequest>* reader,
			                                         K2ResponseMessage* response);
			virtual grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* context,
			                                              grpc::ServerReader<ServiceRequest>* reader,
			                                              K2ResponseMessage* response);
			virtual grpc::Status RequestVRRestart(grpc::ServerContext* context, const ServiceRequest* request,
			                                      K2ResponseMessage* response);
			virtual grpc::Status SetTrackerStateVectorNoReply(grpc::ServerContext* context,
			                                                  grpc::ServerReader<ServiceRequest>* reader,
			                                                  K2ResponseMessage* response);
			virtual grpc::Status UpdateTrackerVectorNoReply(grpc::ServerContext* context,
			                                                grpc::ServerReader<ServiceRequest>* reader,
			                                                K2ResponseMessage* response);
			virtual grpc::Status RefreshTrackerPoseVectorNoReply(grpc::ServerContext* context, grpc::ServerReader<
				                                                     ServiceRequest>* reader,
			                                                     K2ResponseMessage* response);
			virtual grpc::Status RequestVRRestartNoReply(grpc::ServerContext* context, const ServiceRequest* request,
			                                             K2ResponseMessage* response);
		};

		template <class BaseClass>
		class WithAsyncMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodAsync(0);
			}

			~WithAsyncMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                   K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestSetTrackerStateVector(grpc::ServerContext* context, grpc::ServerAsyncReader<K2ResponseMessage,
				                                  ServiceRequest>* reader, grpc::CompletionQueue* new_call_cq,
			                                  grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodAsync(1);
			}

			~WithAsyncMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                 K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestUpdateTrackerVector(grpc::ServerContext* context, grpc::ServerAsyncReader<K2ResponseMessage,
				                                ServiceRequest>* reader, grpc::CompletionQueue* new_call_cq,
			                                grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodAsync(2);
			}

			~WithAsyncMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                      K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRefreshTrackerPoseVector(grpc::ServerContext* context,
			                                     grpc::ServerAsyncReader<K2ResponseMessage,
			                                                             ServiceRequest>* reader,
			                                     grpc::CompletionQueue* new_call_cq,
			                                     grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodAsync(3);
			}

			~WithAsyncMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                              K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRequestVRRestart(grpc::ServerContext* context, ServiceRequest* request,
			                             grpc::ServerAsyncResponseWriter<
				                             K2ResponseMessage>* response, grpc::CompletionQueue* new_call_cq,
			                             grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_SetTrackerStateVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_SetTrackerStateVectorNoReply()
			{
				grpc::Service::MarkMethodAsync(4);
			}

			~WithAsyncMethod_SetTrackerStateVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVectorNoReply(grpc::ServerContext* /*context*/,
			                                          grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                          K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestSetTrackerStateVectorNoReply(grpc::ServerContext* context,
			                                         grpc::ServerAsyncReader<K2ResponseMessage,
			                                                                 ServiceRequest>* reader,
			                                         grpc::CompletionQueue* new_call_cq,
			                                         grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(4, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_UpdateTrackerVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_UpdateTrackerVectorNoReply()
			{
				grpc::Service::MarkMethodAsync(5);
			}

			~WithAsyncMethod_UpdateTrackerVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVectorNoReply(grpc::ServerContext* /*context*/,
			                                        grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                        K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestUpdateTrackerVectorNoReply(grpc::ServerContext* context,
			                                       grpc::ServerAsyncReader<K2ResponseMessage,
			                                                               ServiceRequest>* reader,
			                                       grpc::CompletionQueue* new_call_cq,
			                                       grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(5, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_RefreshTrackerPoseVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_RefreshTrackerPoseVectorNoReply()
			{
				grpc::Service::MarkMethodAsync(6);
			}

			~WithAsyncMethod_RefreshTrackerPoseVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVectorNoReply(grpc::ServerContext* /*context*/,
			                                             grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                             K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRefreshTrackerPoseVectorNoReply(grpc::ServerContext* context, grpc::ServerAsyncReader<
				                                            K2ResponseMessage, ServiceRequest>* reader,
			                                            grpc::CompletionQueue* new_call_cq,
			                                            grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(6, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_RequestVRRestartNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_RequestVRRestartNoReply()
			{
				grpc::Service::MarkMethodAsync(7);
			}

			~WithAsyncMethod_RequestVRRestartNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestartNoReply(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                                     K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRequestVRRestartNoReply(grpc::ServerContext* context, ServiceRequest* request,
			                                    grpc::ServerAsyncResponseWriter<
				                                    K2ResponseMessage>* response, grpc::CompletionQueue* new_call_cq,
			                                    grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		using AsyncService = WithAsyncMethod_SetTrackerStateVector<WithAsyncMethod_UpdateTrackerVector<
			WithAsyncMethod_RefreshTrackerPoseVector<WithAsyncMethod_RequestVRRestart<
				WithAsyncMethod_SetTrackerStateVectorNoReply<WithAsyncMethod_UpdateTrackerVectorNoReply<
					WithAsyncMethod_RefreshTrackerPoseVectorNoReply<WithAsyncMethod_RequestVRRestartNoReply<
						Service>>>>>>>>;

		template <class BaseClass>
		class WithCallbackMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodCallback(0,
				                                  new grpc::internal::CallbackClientStreamingHandler<ServiceRequest,
					                                  K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context, K2ResponseMessage* response)
					                                  {
						                                  return this->SetTrackerStateVector(context, response);
					                                  }));
			}

			~WithCallbackMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                   K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<ServiceRequest>* SetTrackerStateVector(
				grpc::CallbackServerContext* /*context*/, K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodCallback(1,
				                                  new grpc::internal::CallbackClientStreamingHandler<ServiceRequest,
					                                  K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context, K2ResponseMessage* response)
					                                  {
						                                  return this->UpdateTrackerVector(context, response);
					                                  }));
			}

			~WithCallbackMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                 K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<ServiceRequest>* UpdateTrackerVector(
				grpc::CallbackServerContext* /*context*/, K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodCallback(2,
				                                  new grpc::internal::CallbackClientStreamingHandler<ServiceRequest,
					                                  K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context, K2ResponseMessage* response)
					                                  {
						                                  return this->RefreshTrackerPoseVector(context, response);
					                                  }));
			}

			~WithCallbackMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                      K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<ServiceRequest>* RefreshTrackerPoseVector(
				grpc::CallbackServerContext* /*context*/, K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodCallback(3,
				                                  new grpc::internal::CallbackUnaryHandler<
					                                  ServiceRequest, K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context,
					                                  const ServiceRequest* request,
					                                  K2ResponseMessage* response)
					                                  {
						                                  return this->RequestVRRestart(context, request, response);
					                                  }));
			}

			void SetMessageAllocatorFor_RequestVRRestart(
				grpc::MessageAllocator<ServiceRequest, K2ResponseMessage>* allocator)
			{
				grpc::internal::MethodHandler* const handler = grpc::Service::GetHandler(3);
				static_cast<grpc::internal::CallbackUnaryHandler<ServiceRequest, K2ResponseMessage>*>(handler)
					->SetMessageAllocator(allocator);
			}

			~WithCallbackMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                              K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* RequestVRRestart(
				grpc::CallbackServerContext* /*context*/, const ServiceRequest* /*request*/,
				K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_SetTrackerStateVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_SetTrackerStateVectorNoReply()
			{
				grpc::Service::MarkMethodCallback(4,
				                                  new grpc::internal::CallbackClientStreamingHandler<ServiceRequest,
					                                  K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context, K2ResponseMessage* response)
					                                  {
						                                  return this->SetTrackerStateVectorNoReply(context, response);
					                                  }));
			}

			~WithCallbackMethod_SetTrackerStateVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVectorNoReply(grpc::ServerContext* /*context*/,
			                                          grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                          K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<ServiceRequest>* SetTrackerStateVectorNoReply(
				grpc::CallbackServerContext* /*context*/, K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_UpdateTrackerVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_UpdateTrackerVectorNoReply()
			{
				grpc::Service::MarkMethodCallback(5,
				                                  new grpc::internal::CallbackClientStreamingHandler<ServiceRequest,
					                                  K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context, K2ResponseMessage* response)
					                                  {
						                                  return this->UpdateTrackerVectorNoReply(context, response);
					                                  }));
			}

			~WithCallbackMethod_UpdateTrackerVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVectorNoReply(grpc::ServerContext* /*context*/,
			                                        grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                        K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<ServiceRequest>* UpdateTrackerVectorNoReply(
				grpc::CallbackServerContext* /*context*/, K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_RefreshTrackerPoseVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_RefreshTrackerPoseVectorNoReply()
			{
				grpc::Service::MarkMethodCallback(6,
				                                  new grpc::internal::CallbackClientStreamingHandler<ServiceRequest,
					                                  K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context, K2ResponseMessage* response)
					                                  {
						                                  return this->RefreshTrackerPoseVectorNoReply(
							                                  context, response);
					                                  }));
			}

			~WithCallbackMethod_RefreshTrackerPoseVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVectorNoReply(grpc::ServerContext* /*context*/,
			                                             grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                             K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<ServiceRequest>* RefreshTrackerPoseVectorNoReply(
				grpc::CallbackServerContext* /*context*/, K2ResponseMessage* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_RequestVRRestartNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_RequestVRRestartNoReply()
			{
				grpc::Service::MarkMethodCallback(7,
				                                  new grpc::internal::CallbackUnaryHandler<
					                                  ServiceRequest, K2ResponseMessage>(
					                                  [this](
					                                  grpc::CallbackServerContext* context,
					                                  const ServiceRequest* request,
					                                  K2ResponseMessage* response)
					                                  {
						                                  return this->RequestVRRestartNoReply(
							                                  context, request, response);
					                                  }));
			}

			void SetMessageAllocatorFor_RequestVRRestartNoReply(
				grpc::MessageAllocator<ServiceRequest, K2ResponseMessage>* allocator)
			{
				grpc::internal::MethodHandler* const handler = grpc::Service::GetHandler(7);
				static_cast<grpc::internal::CallbackUnaryHandler<ServiceRequest, K2ResponseMessage>*>(handler)
					->SetMessageAllocator(allocator);
			}

			~WithCallbackMethod_RequestVRRestartNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestartNoReply(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                                     K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* RequestVRRestartNoReply(
				grpc::CallbackServerContext* /*context*/, const ServiceRequest* /*request*/,
				K2ResponseMessage* /*response*/) { return nullptr; }
		};

		using CallbackService = WithCallbackMethod_SetTrackerStateVector<WithCallbackMethod_UpdateTrackerVector<
			WithCallbackMethod_RefreshTrackerPoseVector<WithCallbackMethod_RequestVRRestart<
				WithCallbackMethod_SetTrackerStateVectorNoReply<WithCallbackMethod_UpdateTrackerVectorNoReply<
					WithCallbackMethod_RefreshTrackerPoseVectorNoReply<WithCallbackMethod_RequestVRRestartNoReply<
						Service>>>>>>>>;
		using ExperimentalCallbackService = CallbackService;

		template <class BaseClass>
		class WithGenericMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodGeneric(0);
			}

			~WithGenericMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                   K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodGeneric(1);
			}

			~WithGenericMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                 K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodGeneric(2);
			}

			~WithGenericMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                      K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodGeneric(3);
			}

			~WithGenericMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                              K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_SetTrackerStateVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_SetTrackerStateVectorNoReply()
			{
				grpc::Service::MarkMethodGeneric(4);
			}

			~WithGenericMethod_SetTrackerStateVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVectorNoReply(grpc::ServerContext* /*context*/,
			                                          grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                          K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_UpdateTrackerVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_UpdateTrackerVectorNoReply()
			{
				grpc::Service::MarkMethodGeneric(5);
			}

			~WithGenericMethod_UpdateTrackerVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVectorNoReply(grpc::ServerContext* /*context*/,
			                                        grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                        K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_RefreshTrackerPoseVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_RefreshTrackerPoseVectorNoReply()
			{
				grpc::Service::MarkMethodGeneric(6);
			}

			~WithGenericMethod_RefreshTrackerPoseVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVectorNoReply(grpc::ServerContext* /*context*/,
			                                             grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                             K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_RequestVRRestartNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_RequestVRRestartNoReply()
			{
				grpc::Service::MarkMethodGeneric(7);
			}

			~WithGenericMethod_RequestVRRestartNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestartNoReply(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                                     K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithRawMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodRaw(0);
			}

			~WithRawMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                   K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestSetTrackerStateVector(grpc::ServerContext* context, grpc::ServerAsyncReader<grpc::ByteBuffer,
				                                  grpc::ByteBuffer>* reader, grpc::CompletionQueue* new_call_cq,
			                                  grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodRaw(1);
			}

			~WithRawMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                 K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestUpdateTrackerVector(grpc::ServerContext* context, grpc::ServerAsyncReader<grpc::ByteBuffer,
				                                grpc::ByteBuffer>* reader, grpc::CompletionQueue* new_call_cq,
			                                grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodRaw(2);
			}

			~WithRawMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                      K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRefreshTrackerPoseVector(grpc::ServerContext* context, grpc::ServerAsyncReader<grpc::ByteBuffer,
				                                     grpc::ByteBuffer>* reader, grpc::CompletionQueue* new_call_cq,
			                                     grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodRaw(3);
			}

			~WithRawMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                              K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRequestVRRestart(grpc::ServerContext* context, grpc::ByteBuffer* request,
			                             grpc::ServerAsyncResponseWriter<
				                             grpc::ByteBuffer>* response, grpc::CompletionQueue* new_call_cq,
			                             grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_SetTrackerStateVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_SetTrackerStateVectorNoReply()
			{
				grpc::Service::MarkMethodRaw(4);
			}

			~WithRawMethod_SetTrackerStateVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVectorNoReply(grpc::ServerContext* /*context*/,
			                                          grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                          K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestSetTrackerStateVectorNoReply(grpc::ServerContext* context,
			                                         grpc::ServerAsyncReader<grpc::ByteBuffer,
			                                                                 grpc::ByteBuffer>* reader,
			                                         grpc::CompletionQueue* new_call_cq,
			                                         grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(4, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_UpdateTrackerVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_UpdateTrackerVectorNoReply()
			{
				grpc::Service::MarkMethodRaw(5);
			}

			~WithRawMethod_UpdateTrackerVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVectorNoReply(grpc::ServerContext* /*context*/,
			                                        grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                        K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestUpdateTrackerVectorNoReply(grpc::ServerContext* context,
			                                       grpc::ServerAsyncReader<grpc::ByteBuffer,
			                                                               grpc::ByteBuffer>* reader,
			                                       grpc::CompletionQueue* new_call_cq,
			                                       grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(5, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_RefreshTrackerPoseVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_RefreshTrackerPoseVectorNoReply()
			{
				grpc::Service::MarkMethodRaw(6);
			}

			~WithRawMethod_RefreshTrackerPoseVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVectorNoReply(grpc::ServerContext* /*context*/,
			                                             grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                             K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRefreshTrackerPoseVectorNoReply(grpc::ServerContext* context,
			                                            grpc::ServerAsyncReader<grpc::ByteBuffer,
				                                            grpc::ByteBuffer>* reader,
			                                            grpc::CompletionQueue* new_call_cq,
			                                            grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncClientStreaming(6, context, reader, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_RequestVRRestartNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_RequestVRRestartNoReply()
			{
				grpc::Service::MarkMethodRaw(7);
			}

			~WithRawMethod_RequestVRRestartNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestartNoReply(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                                     K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRequestVRRestartNoReply(grpc::ServerContext* context, grpc::ByteBuffer* request,
			                                    grpc::ServerAsyncResponseWriter<
				                                    grpc::ByteBuffer>* response, grpc::CompletionQueue* new_call_cq,
			                                    grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawCallbackMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodRawCallback(0,
				                                     new grpc::internal::CallbackClientStreamingHandler<
					                                     grpc::ByteBuffer,
					                                     grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->SetTrackerStateVector(context, response);
					                                     }));
			}

			~WithRawCallbackMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                   K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<grpc::ByteBuffer>* SetTrackerStateVector(
				grpc::CallbackServerContext* /*context*/, grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodRawCallback(1,
				                                     new grpc::internal::CallbackClientStreamingHandler<
					                                     grpc::ByteBuffer,
					                                     grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->UpdateTrackerVector(context, response);
					                                     }));
			}

			~WithRawCallbackMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                 K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<grpc::ByteBuffer>* UpdateTrackerVector(
				grpc::CallbackServerContext* /*context*/, grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodRawCallback(2,
				                                     new grpc::internal::CallbackClientStreamingHandler<
					                                     grpc::ByteBuffer,
					                                     grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->RefreshTrackerPoseVector(context, response);
					                                     }));
			}

			~WithRawCallbackMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                      K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<grpc::ByteBuffer>* RefreshTrackerPoseVector(
				grpc::CallbackServerContext* /*context*/, grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodRawCallback(3,
				                                     new grpc::internal::CallbackUnaryHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     const grpc::ByteBuffer* request,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->RequestVRRestart(context, request, response);
					                                     }));
			}

			~WithRawCallbackMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                              K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* RequestVRRestart(
				grpc::CallbackServerContext* /*context*/, const grpc::ByteBuffer* /*request*/,
				grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_SetTrackerStateVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_SetTrackerStateVectorNoReply()
			{
				grpc::Service::MarkMethodRawCallback(4,
				                                     new grpc::internal::CallbackClientStreamingHandler<
					                                     grpc::ByteBuffer,
					                                     grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->SetTrackerStateVectorNoReply(
							                                     context, response);
					                                     }));
			}

			~WithRawCallbackMethod_SetTrackerStateVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVectorNoReply(grpc::ServerContext* /*context*/,
			                                          grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                          K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<grpc::ByteBuffer>* SetTrackerStateVectorNoReply(
				grpc::CallbackServerContext* /*context*/, grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_UpdateTrackerVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_UpdateTrackerVectorNoReply()
			{
				grpc::Service::MarkMethodRawCallback(5,
				                                     new grpc::internal::CallbackClientStreamingHandler<
					                                     grpc::ByteBuffer,
					                                     grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->UpdateTrackerVectorNoReply(context, response);
					                                     }));
			}

			~WithRawCallbackMethod_UpdateTrackerVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVectorNoReply(grpc::ServerContext* /*context*/,
			                                        grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                        K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<grpc::ByteBuffer>* UpdateTrackerVectorNoReply(
				grpc::CallbackServerContext* /*context*/, grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_RefreshTrackerPoseVectorNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_RefreshTrackerPoseVectorNoReply()
			{
				grpc::Service::MarkMethodRawCallback(6,
				                                     new grpc::internal::CallbackClientStreamingHandler<
					                                     grpc::ByteBuffer,
					                                     grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->RefreshTrackerPoseVectorNoReply(
							                                     context, response);
					                                     }));
			}

			~WithRawCallbackMethod_RefreshTrackerPoseVectorNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVectorNoReply(grpc::ServerContext* /*context*/,
			                                             grpc::ServerReader<ServiceRequest>* /*reader*/,
			                                             K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerReadReactor<grpc::ByteBuffer>* RefreshTrackerPoseVectorNoReply(
				grpc::CallbackServerContext* /*context*/, grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_RequestVRRestartNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_RequestVRRestartNoReply()
			{
				grpc::Service::MarkMethodRawCallback(7,
				                                     new grpc::internal::CallbackUnaryHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     const grpc::ByteBuffer* request,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->RequestVRRestartNoReply(
							                                     context, request, response);
					                                     }));
			}

			~WithRawCallbackMethod_RequestVRRestartNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestartNoReply(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                                     K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* RequestVRRestartNoReply(
				grpc::CallbackServerContext* /*context*/, const grpc::ByteBuffer* /*request*/,
				grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithStreamedUnaryMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithStreamedUnaryMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodStreamed(3,
				                                  new grpc::internal::StreamedUnaryHandler<
					                                  ServiceRequest, K2ResponseMessage>(
					                                  [this](grpc::ServerContext* context,
					                                         grpc::ServerUnaryStreamer<
						                                         ServiceRequest, K2ResponseMessage>* streamer)
					                                  {
						                                  return this->StreamedRequestVRRestart(context,
							                                  streamer);
					                                  }));
			}

			~WithStreamedUnaryMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable regular version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                              K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			// replace default version of method with streamed unary
			virtual grpc::Status StreamedRequestVRRestart(grpc::ServerContext* context, grpc::ServerUnaryStreamer<
				                                              ServiceRequest, K2ResponseMessage>* server_unary_streamer)
			= 0;
		};

		template <class BaseClass>
		class WithStreamedUnaryMethod_RequestVRRestartNoReply : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithStreamedUnaryMethod_RequestVRRestartNoReply()
			{
				grpc::Service::MarkMethodStreamed(7,
				                                  new grpc::internal::StreamedUnaryHandler<
					                                  ServiceRequest, K2ResponseMessage>(
					                                  [this](grpc::ServerContext* context,
					                                         grpc::ServerUnaryStreamer<
						                                         ServiceRequest, K2ResponseMessage>* streamer)
					                                  {
						                                  return this->StreamedRequestVRRestartNoReply(context,
							                                  streamer);
					                                  }));
			}

			~WithStreamedUnaryMethod_RequestVRRestartNoReply() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable regular version of this method
			grpc::Status RequestVRRestartNoReply(grpc::ServerContext* /*context*/, const ServiceRequest* /*request*/,
			                                     K2ResponseMessage* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			// replace default version of method with streamed unary
			virtual grpc::Status StreamedRequestVRRestartNoReply(grpc::ServerContext* context,
			                                                     grpc::ServerUnaryStreamer<
				                                                     ServiceRequest, K2ResponseMessage>*
			                                                     server_unary_streamer) = 0;
		};

		using StreamedUnaryService = WithStreamedUnaryMethod_RequestVRRestart<
			WithStreamedUnaryMethod_RequestVRRestartNoReply<Service>>;
		using SplitStreamedService = Service;
		using StreamedService = WithStreamedUnaryMethod_RequestVRRestart<WithStreamedUnaryMethod_RequestVRRestartNoReply
			<Service>>;
	};
} // namespace ktvr


#endif  // GRPC_Amethyst_5fAPI_2eproto__INCLUDED
