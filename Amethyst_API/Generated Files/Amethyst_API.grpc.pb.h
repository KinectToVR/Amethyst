// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Amethyst_API.proto
#ifndef GRPC_Amethyst_5fAPI_2eproto__INCLUDED
#define GRPC_Amethyst_5fAPI_2eproto__INCLUDED

#include "Amethyst_API.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace ktvr
{
	inline const char* IK2DriverService_method_names[] = {
		"/ktvr.IK2DriverService/SetTrackerStateVector",
		"/ktvr.IK2DriverService/UpdateTrackerVector",
		"/ktvr.IK2DriverService/RefreshTrackerPoseVector",
		"/ktvr.IK2DriverService/RequestVRRestart",
		"/ktvr.IK2DriverService/PingDriverService",
	};

	class IK2DriverService final
	{
	public:
		static constexpr const char* service_full_name()
		{
			return "ktvr.IK2DriverService";
		}

		class StubInterface
		{
		public:
			virtual ~StubInterface()
			{
			}

			// Note: 'state' becomes a 'success' check on return
			std::unique_ptr<grpc::ClientReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> SetTrackerStateVector(
				grpc::ClientContext* context)
			{
				return std::unique_ptr<grpc::ClientReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(SetTrackerStateVectorRaw(context));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> AsyncSetTrackerStateVector(
				grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(
					AsyncSetTrackerStateVectorRaw(context, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> PrepareAsyncSetTrackerStateVector(
				grpc::ClientContext* context, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(
					PrepareAsyncSetTrackerStateVectorRaw(context, cq));
			}

			std::unique_ptr<grpc::ClientReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> UpdateTrackerVector(
				grpc::ClientContext* context)
			{
				return std::unique_ptr<grpc::ClientReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(UpdateTrackerVectorRaw(context));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> AsyncUpdateTrackerVector(
				grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(
					AsyncUpdateTrackerVectorRaw(context, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> PrepareAsyncUpdateTrackerVector(
				grpc::ClientContext* context, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(
					PrepareAsyncUpdateTrackerVectorRaw(context, cq));
			}

			std::unique_ptr<grpc::ClientReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> RefreshTrackerPoseVector(
				grpc::ClientContext* context)
			{
				return std::unique_ptr<grpc::ClientReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(RefreshTrackerPoseVectorRaw(context));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> AsyncRefreshTrackerPoseVector(
				grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(
					AsyncRefreshTrackerPoseVectorRaw(context, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
				ServiceRequest, Service_TrackerStatePair>> PrepareAsyncRefreshTrackerPoseVector(
				grpc::ClientContext* context, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriterInterface<
					ServiceRequest, Service_TrackerStatePair>>(
					PrepareAsyncRefreshTrackerPoseVectorRaw(context, cq));
			}

			virtual grpc::Status RequestVRRestart(grpc::ClientContext* context,
			                                      const ServiceRequest& request,
			                                      Service_TrackerStatePair* response) = 0;

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<Service_TrackerStatePair>>
			AsyncRequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
			                      grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<Service_TrackerStatePair>>(
					AsyncRequestVRRestartRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<Service_TrackerStatePair>>
			PrepareAsyncRequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
			                             grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<Service_TrackerStatePair>>(
					PrepareAsyncRequestVRRestartRaw(context, request, cq));
			}

			virtual grpc::Status PingDriverService(grpc::ClientContext* context,
			                                       const google::protobuf::Empty& request,
			                                       PingRequest* response) = 0;

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<PingRequest>> AsyncPingDriverService(
				grpc::ClientContext* context, const google::protobuf::Empty& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<PingRequest>>(
					AsyncPingDriverServiceRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<PingRequest>>
			PrepareAsyncPingDriverService(grpc::ClientContext* context, const google::protobuf::Empty& request,
			                              grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReaderInterface<PingRequest>>(
					PrepareAsyncPingDriverServiceRaw(context, request, cq));
			}

			class async_interface
			{
			public:
				virtual ~async_interface()
				{
				}

				// Note: 'state' becomes a 'success' check on return
				virtual void SetTrackerStateVector(grpc::ClientContext* context,
				                                   grpc::ClientBidiReactor<
					                                   ServiceRequest, Service_TrackerStatePair>*
				                                   reactor) = 0;
				virtual void UpdateTrackerVector(grpc::ClientContext* context,
				                                 grpc::ClientBidiReactor<
					                                 ServiceRequest, Service_TrackerStatePair>* reactor)
				= 0;
				virtual void RefreshTrackerPoseVector(grpc::ClientContext* context,
				                                      grpc::ClientBidiReactor<
					                                      ServiceRequest, Service_TrackerStatePair>*
				                                      reactor) = 0;
				virtual void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                              Service_TrackerStatePair* response,
				                              std::function<void(grpc::Status)>) = 0;
				virtual void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                              Service_TrackerStatePair* response,
				                              grpc::ClientUnaryReactor* reactor) = 0;
				virtual void PingDriverService(grpc::ClientContext* context, const google::protobuf::Empty* request,
				                               PingRequest* response, std::function<void(grpc::Status)>) = 0;
				virtual void PingDriverService(grpc::ClientContext* context, const google::protobuf::Empty* request,
				                               PingRequest* response, grpc::ClientUnaryReactor* reactor) = 0;
			};

			using experimental_async_interface = class async_interface;
			virtual class async_interface* async() { return nullptr; }
			class async_interface* experimental_async() { return async(); }

		private:
			virtual grpc::ClientReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			SetTrackerStateVectorRaw(grpc::ClientContext* context) = 0;
			virtual grpc::ClientAsyncReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			AsyncSetTrackerStateVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			PrepareAsyncSetTrackerStateVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			UpdateTrackerVectorRaw(grpc::ClientContext* context) = 0;
			virtual grpc::ClientAsyncReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			AsyncUpdateTrackerVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag) = 0;
			virtual grpc::ClientAsyncReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			PrepareAsyncUpdateTrackerVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			RefreshTrackerPoseVectorRaw(grpc::ClientContext* context) = 0;
			virtual grpc::ClientAsyncReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			AsyncRefreshTrackerPoseVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag) =
			0;
			virtual grpc::ClientAsyncReaderWriterInterface<ServiceRequest, Service_TrackerStatePair>*
			PrepareAsyncRefreshTrackerPoseVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<Service_TrackerStatePair>*
			AsyncRequestVRRestartRaw(grpc::ClientContext* context, const ServiceRequest& request,
			                         grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<Service_TrackerStatePair>*
			PrepareAsyncRequestVRRestartRaw(grpc::ClientContext* context, const ServiceRequest& request,
			                                grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<PingRequest>* AsyncPingDriverServiceRaw(
				grpc::ClientContext* context, const google::protobuf::Empty& request,
				grpc::CompletionQueue* cq) = 0;
			virtual grpc::ClientAsyncResponseReaderInterface<PingRequest>* PrepareAsyncPingDriverServiceRaw(
				grpc::ClientContext* context, const google::protobuf::Empty& request,
				grpc::CompletionQueue* cq) = 0;
		};

		class Stub final : public StubInterface
		{
		public:
			Stub(const std::shared_ptr<grpc::ChannelInterface>& channel,
			     const grpc::StubOptions& options = grpc::StubOptions())
				: channel_(channel), rpcmethod_SetTrackerStateVector_(IK2DriverService_method_names[0],
				                                                      options.suffix_for_stats(),
				                                                      grpc::internal::RpcMethod::BIDI_STREAMING,
				                                                      channel)
				  , rpcmethod_UpdateTrackerVector_(IK2DriverService_method_names[1], options.suffix_for_stats(),
				                                   grpc::internal::RpcMethod::BIDI_STREAMING, channel)
				  , rpcmethod_RefreshTrackerPoseVector_(IK2DriverService_method_names[2], options.suffix_for_stats(),
				                                        grpc::internal::RpcMethod::BIDI_STREAMING, channel)
				  , rpcmethod_RequestVRRestart_(IK2DriverService_method_names[3], options.suffix_for_stats(),
				                                grpc::internal::RpcMethod::NORMAL_RPC, channel)
				  , rpcmethod_PingDriverService_(IK2DriverService_method_names[4], options.suffix_for_stats(),
				                                 grpc::internal::RpcMethod::NORMAL_RPC, channel)
			{
			}

			std::unique_ptr<grpc::ClientReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			SetTrackerStateVector(grpc::ClientContext* context)
			{
				return std::unique_ptr<grpc::ClientReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(SetTrackerStateVectorRaw(context));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			AsyncSetTrackerStateVector(grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(
					AsyncSetTrackerStateVectorRaw(context, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			PrepareAsyncSetTrackerStateVector(grpc::ClientContext* context, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(
					PrepareAsyncSetTrackerStateVectorRaw(context, cq));
			}

			std::unique_ptr<grpc::ClientReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			UpdateTrackerVector(grpc::ClientContext* context)
			{
				return std::unique_ptr<grpc::ClientReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(UpdateTrackerVectorRaw(context));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			AsyncUpdateTrackerVector(grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(
					AsyncUpdateTrackerVectorRaw(context, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			PrepareAsyncUpdateTrackerVector(grpc::ClientContext* context, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(
					PrepareAsyncUpdateTrackerVectorRaw(context, cq));
			}

			std::unique_ptr<grpc::ClientReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			RefreshTrackerPoseVector(grpc::ClientContext* context)
			{
				return std::unique_ptr<grpc::ClientReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(RefreshTrackerPoseVectorRaw(context));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			AsyncRefreshTrackerPoseVector(grpc::ClientContext* context, grpc::CompletionQueue* cq, void* tag)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(
					AsyncRefreshTrackerPoseVectorRaw(context, cq, tag));
			}

			std::unique_ptr<grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>>
			PrepareAsyncRefreshTrackerPoseVector(grpc::ClientContext* context, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncReaderWriter<
					ServiceRequest, Service_TrackerStatePair>>(
					PrepareAsyncRefreshTrackerPoseVectorRaw(context, cq));
			}

			grpc::Status RequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
			                              Service_TrackerStatePair* response) override
			{
				return ::grpc::internal::BlockingUnaryCall<
					ServiceRequest, Service_TrackerStatePair, grpc::protobuf::MessageLite,
					grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_RequestVRRestart_, context, request,
					                             response);
			}

			std::unique_ptr<grpc::ClientAsyncResponseReader<Service_TrackerStatePair>> AsyncRequestVRRestart(
				grpc::ClientContext* context, const ServiceRequest& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<Service_TrackerStatePair>>(
					AsyncRequestVRRestartRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReader<Service_TrackerStatePair>>
			PrepareAsyncRequestVRRestart(grpc::ClientContext* context, const ServiceRequest& request,
			                             grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<Service_TrackerStatePair>>(
					PrepareAsyncRequestVRRestartRaw(context, request, cq));
			}

			grpc::Status PingDriverService(grpc::ClientContext* context, const google::protobuf::Empty& request,
			                               PingRequest* response) override
			{
				return ::grpc::internal::BlockingUnaryCall<
					google::protobuf::Empty, PingRequest, grpc::protobuf::MessageLite,
					grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_PingDriverService_, context, request,
					                             response);
			}

			std::unique_ptr<grpc::ClientAsyncResponseReader<PingRequest>> AsyncPingDriverService(
				grpc::ClientContext* context, const google::protobuf::Empty& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<PingRequest>>(
					AsyncPingDriverServiceRaw(context, request, cq));
			}

			std::unique_ptr<grpc::ClientAsyncResponseReader<PingRequest>> PrepareAsyncPingDriverService(
				grpc::ClientContext* context, const google::protobuf::Empty& request, grpc::CompletionQueue* cq)
			{
				return std::unique_ptr<grpc::ClientAsyncResponseReader<PingRequest>>(
					PrepareAsyncPingDriverServiceRaw(context, request, cq));
			}

			class async final :
				public async_interface
			{
			public:
				void SetTrackerStateVector(grpc::ClientContext* context,
				                           grpc::ClientBidiReactor<
					                           ServiceRequest, Service_TrackerStatePair>*
				                           reactor) override
				{
					grpc::internal::ClientCallbackReaderWriterFactory<
						ServiceRequest, Service_TrackerStatePair>::Create(
						stub_->channel_.get(), stub_->rpcmethod_SetTrackerStateVector_, context, reactor);
				}

				void UpdateTrackerVector(grpc::ClientContext* context,
				                         grpc::ClientBidiReactor<
					                         ServiceRequest, Service_TrackerStatePair>*
				                         reactor) override
				{
					grpc::internal::ClientCallbackReaderWriterFactory<
						ServiceRequest, Service_TrackerStatePair>::Create(
						stub_->channel_.get(), stub_->rpcmethod_UpdateTrackerVector_, context, reactor);
				}

				void RefreshTrackerPoseVector(grpc::ClientContext* context,
				                              grpc::ClientBidiReactor<
					                              ServiceRequest, Service_TrackerStatePair>*
				                              reactor) override
				{
					grpc::internal::ClientCallbackReaderWriterFactory<
						ServiceRequest, Service_TrackerStatePair>::Create(
						stub_->channel_.get(), stub_->rpcmethod_RefreshTrackerPoseVector_, context, reactor);
				}

				void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                      Service_TrackerStatePair* response,
				                      std::function<void(grpc::Status)> f) override
				{
					::grpc::internal::CallbackUnaryCall<ServiceRequest, Service_TrackerStatePair,
					                                    grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
						stub_->channel_.get(), stub_->rpcmethod_RequestVRRestart_, context, request, response,
						std::move(f));
				}

				void RequestVRRestart(grpc::ClientContext* context, const ServiceRequest* request,
				                      Service_TrackerStatePair* response,
				                      grpc::ClientUnaryReactor* reactor) override
				{
					grpc::internal::ClientCallbackUnaryFactory::Create<
						grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
						stub_->channel_.get(), stub_->rpcmethod_RequestVRRestart_, context, request, response, reactor);
				}

				void PingDriverService(grpc::ClientContext* context, const google::protobuf::Empty* request,
				                       PingRequest* response, std::function<void(grpc::Status)> f) override
				{
					::grpc::internal::CallbackUnaryCall<google::protobuf::Empty, PingRequest,
					                                    grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
						stub_->channel_.get(), stub_->rpcmethod_PingDriverService_, context, request, response,
						std::move(f));
				}

				void PingDriverService(grpc::ClientContext* context, const google::protobuf::Empty* request,
				                       PingRequest* response, grpc::ClientUnaryReactor* reactor) override
				{
					grpc::internal::ClientCallbackUnaryFactory::Create<
						grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
						stub_->channel_.get(), stub_->rpcmethod_PingDriverService_, context, request, response,
						reactor);
				}

			private:
				friend class Stub;

				explicit async(Stub* stub): stub_(stub)
				{
				}

				Stub* stub() { return stub_; }
				Stub* stub_;
			};

			class async* async() override { return &async_stub_; }

		private:
			std::shared_ptr<grpc::ChannelInterface> channel_;
			class async async_stub_{this};

			grpc::ClientReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			SetTrackerStateVectorRaw(grpc::ClientContext* context) override
			{
				return grpc::internal::ClientReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), rpcmethod_SetTrackerStateVector_, context);
			}

			grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			AsyncSetTrackerStateVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq,
			                              void* tag) override
			{
				return grpc::internal::ClientAsyncReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), cq, rpcmethod_SetTrackerStateVector_, context, true, tag);
			}

			grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			PrepareAsyncSetTrackerStateVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq) override
			{
				return grpc::internal::ClientAsyncReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), cq, rpcmethod_SetTrackerStateVector_, context, false, nullptr);
			}

			grpc::ClientReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			UpdateTrackerVectorRaw(grpc::ClientContext* context) override
			{
				return grpc::internal::ClientReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), rpcmethod_UpdateTrackerVector_, context);
			}

			grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			AsyncUpdateTrackerVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq,
			                            void* tag) override
			{
				return grpc::internal::ClientAsyncReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), cq, rpcmethod_UpdateTrackerVector_, context, true, tag);
			}

			grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			PrepareAsyncUpdateTrackerVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq) override
			{
				return grpc::internal::ClientAsyncReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), cq, rpcmethod_UpdateTrackerVector_, context, false, nullptr);
			}

			grpc::ClientReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			RefreshTrackerPoseVectorRaw(grpc::ClientContext* context) override
			{
				return grpc::internal::ClientReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), rpcmethod_RefreshTrackerPoseVector_, context);
			}

			grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			AsyncRefreshTrackerPoseVectorRaw(grpc::ClientContext* context, grpc::CompletionQueue* cq,
			                                 void* tag) override
			{
				return grpc::internal::ClientAsyncReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), cq, rpcmethod_RefreshTrackerPoseVector_, context, true, tag);
			}

			grpc::ClientAsyncReaderWriter<ServiceRequest, Service_TrackerStatePair>*
			PrepareAsyncRefreshTrackerPoseVectorRaw(grpc::ClientContext* context,
			                                        grpc::CompletionQueue* cq) override
			{
				return grpc::internal::ClientAsyncReaderWriterFactory<
					ServiceRequest, Service_TrackerStatePair>::Create(
					channel_.get(), cq, rpcmethod_RefreshTrackerPoseVector_, context, false, nullptr);
			}

			grpc::ClientAsyncResponseReader<Service_TrackerStatePair>* AsyncRequestVRRestartRaw(
				grpc::ClientContext* context, const ServiceRequest& request,
				grpc::CompletionQueue* cq) override
			{
				auto* result =
					this->PrepareAsyncRequestVRRestartRaw(context, request, cq);
				result->StartCall();
				return result;
			}

			grpc::ClientAsyncResponseReader<Service_TrackerStatePair>* PrepareAsyncRequestVRRestartRaw(
				grpc::ClientContext* context, const ServiceRequest& request,
				grpc::CompletionQueue* cq) override
			{
				return grpc::internal::ClientAsyncResponseReaderHelper::Create<
					Service_TrackerStatePair, ServiceRequest, grpc::protobuf::MessageLite,
					grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RequestVRRestart_, context, request);
			}

			grpc::ClientAsyncResponseReader<PingRequest>* AsyncPingDriverServiceRaw(
				grpc::ClientContext* context, const google::protobuf::Empty& request,
				grpc::CompletionQueue* cq) override
			{
				auto* result =
					this->PrepareAsyncPingDriverServiceRaw(context, request, cq);
				result->StartCall();
				return result;
			}

			grpc::ClientAsyncResponseReader<PingRequest>* PrepareAsyncPingDriverServiceRaw(
				grpc::ClientContext* context, const google::protobuf::Empty& request,
				grpc::CompletionQueue* cq) override
			{
				return grpc::internal::ClientAsyncResponseReaderHelper::Create<
					PingRequest, google::protobuf::Empty, grpc::protobuf::MessageLite,
					grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_PingDriverService_, context, request);
			}

			const grpc::internal::RpcMethod rpcmethod_SetTrackerStateVector_;
			const grpc::internal::RpcMethod rpcmethod_UpdateTrackerVector_;
			const grpc::internal::RpcMethod rpcmethod_RefreshTrackerPoseVector_;
			const grpc::internal::RpcMethod rpcmethod_RequestVRRestart_;
			const grpc::internal::RpcMethod rpcmethod_PingDriverService_;
		};

		static std::unique_ptr<Stub> NewStub(const std::shared_ptr<grpc::ChannelInterface>& channel,
		                                     const grpc::StubOptions& options = grpc::StubOptions())
		{
			(void)options;
			std::unique_ptr<Stub> stub(new Stub(channel, options));
			return stub;
		}

		class Service : public grpc::Service
		{
		public:
			Service()
			{
				AddMethod(new grpc::internal::RpcServiceMethod(
					IK2DriverService_method_names[0],
					grpc::internal::RpcMethod::BIDI_STREAMING,
					new grpc::internal::BidiStreamingHandler<
						Service, ServiceRequest, Service_TrackerStatePair>(
						[](Service* service,
						   grpc::ServerContext* ctx,
						   grpc::ServerReaderWriter<Service_TrackerStatePair,
						                            ServiceRequest>* stream)
						{
							return service->SetTrackerStateVector(ctx, stream);
						}, this)));
				AddMethod(new grpc::internal::RpcServiceMethod(
					IK2DriverService_method_names[1],
					grpc::internal::RpcMethod::BIDI_STREAMING,
					new grpc::internal::BidiStreamingHandler<
						Service, ServiceRequest, Service_TrackerStatePair>(
						[](Service* service,
						   grpc::ServerContext* ctx,
						   grpc::ServerReaderWriter<Service_TrackerStatePair,
						                            ServiceRequest>* stream)
						{
							return service->UpdateTrackerVector(ctx, stream);
						}, this)));
				AddMethod(new grpc::internal::RpcServiceMethod(
					IK2DriverService_method_names[2],
					grpc::internal::RpcMethod::BIDI_STREAMING,
					new grpc::internal::BidiStreamingHandler<
						Service, ServiceRequest, Service_TrackerStatePair>(
						[](Service* service,
						   grpc::ServerContext* ctx,
						   grpc::ServerReaderWriter<Service_TrackerStatePair,
						                            ServiceRequest>* stream)
						{
							return service->RefreshTrackerPoseVector(ctx, stream);
						}, this)));
				AddMethod(new grpc::internal::RpcServiceMethod(
					IK2DriverService_method_names[3],
					grpc::internal::RpcMethod::NORMAL_RPC,
					new grpc::internal::RpcMethodHandler<
						Service, ServiceRequest, Service_TrackerStatePair,
						grpc::protobuf::MessageLite, grpc::protobuf::MessageLite>(
						[](Service* service,
						   grpc::ServerContext* ctx,
						   const ServiceRequest* req,
						   Service_TrackerStatePair* resp)
						{
							return service->RequestVRRestart(ctx, req, resp);
						}, this)));
				AddMethod(new grpc::internal::RpcServiceMethod(
					IK2DriverService_method_names[4],
					grpc::internal::RpcMethod::NORMAL_RPC,
					new grpc::internal::RpcMethodHandler<
						Service, google::protobuf::Empty, PingRequest,
						grpc::protobuf::MessageLite
						, grpc::protobuf::MessageLite>(
						[](Service* service,
						   grpc::ServerContext* ctx,
						   const google::protobuf::Empty* req,
						   PingRequest* resp)
						{
							return service->PingDriverService(ctx, req, resp);
						}, this)));
			}

			~Service() override = default;

			// https://github.com/grpc/grpc/issues/15653
			Service(const Service&) = delete;
			Service& operator =(const Service&) = delete;

			// Note: 'state' becomes a 'success' check on return
			virtual grpc::Status SetTrackerStateVector(grpc::ServerContext* context,
			                                           grpc::ServerReaderWriter<
				                                           Service_TrackerStatePair, ServiceRequest>*
			                                           stream)
			{
				(void)context;
				(void)stream;
				return { grpc::StatusCode::UNIMPLEMENTED, "" };
			}

			virtual grpc::Status UpdateTrackerVector(grpc::ServerContext* context,
			                                         grpc::ServerReaderWriter<
				                                         Service_TrackerStatePair, ServiceRequest>*
			                                         stream)
			{
				(void)context;
				(void)stream;
				return { grpc::StatusCode::UNIMPLEMENTED, "" };
			}

			virtual grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* context,
			                                              grpc::ServerReaderWriter<
				                                              Service_TrackerStatePair,
				                                              ServiceRequest>* stream)
			{
				(void)context;
				(void)stream;
				return { grpc::StatusCode::UNIMPLEMENTED, "" };
			}

			virtual grpc::Status RequestVRRestart(grpc::ServerContext* context,
			                                      const ServiceRequest* request,
			                                      Service_TrackerStatePair* response)
			{
				(void)context;
				(void)request;
				(void)response;
				return { grpc::StatusCode::UNIMPLEMENTED, "" };
			}

			virtual grpc::Status PingDriverService(grpc::ServerContext* context,
			                                       const google::protobuf::Empty* request,
			                                       PingRequest* response)
			{
				(void)context;
				(void)request;
				(void)response;
				return { grpc::StatusCode::UNIMPLEMENTED, "" };
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodAsync(0);
			}

			~WithAsyncMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReaderWriter<
				                                   Service_TrackerStatePair, ServiceRequest>*
			                                   /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestSetTrackerStateVector(grpc::ServerContext* context,
			                                  grpc::ServerAsyncReaderWriter<
				                                  Service_TrackerStatePair, ServiceRequest>* stream,
			                                  grpc::CompletionQueue* new_call_cq,
			                                  grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodAsync(1);
			}

			~WithAsyncMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReaderWriter<
				                                 Service_TrackerStatePair, ServiceRequest>* /*stream*/
			) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestUpdateTrackerVector(grpc::ServerContext* context,
			                                grpc::ServerAsyncReaderWriter<
				                                Service_TrackerStatePair, ServiceRequest>* stream,
			                                grpc::CompletionQueue* new_call_cq,
			                                grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodAsync(2);
			}

			~WithAsyncMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReaderWriter<
				                                      Service_TrackerStatePair, ServiceRequest>*
			                                      /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRefreshTrackerPoseVector(grpc::ServerContext* context,
			                                     grpc::ServerAsyncReaderWriter<
				                                     Service_TrackerStatePair, ServiceRequest>* stream,
			                                     grpc::CompletionQueue* new_call_cq,
			                                     grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodAsync(3);
			}

			~WithAsyncMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/,
			                              const ServiceRequest* /*request*/,
			                              Service_TrackerStatePair* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRequestVRRestart(grpc::ServerContext* context, ServiceRequest* request,
			                             grpc::ServerAsyncResponseWriter<Service_TrackerStatePair>* response,
			                             grpc::CompletionQueue* new_call_cq,
			                             grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithAsyncMethod_PingDriverService : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithAsyncMethod_PingDriverService()
			{
				grpc::Service::MarkMethodAsync(4);
			}

			~WithAsyncMethod_PingDriverService() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status PingDriverService(grpc::ServerContext* /*context*/,
			                               const google::protobuf::Empty* /*request*/,
			                               PingRequest* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestPingDriverService(grpc::ServerContext* context, google::protobuf::Empty* request,
			                              grpc::ServerAsyncResponseWriter<PingRequest>* response,
			                              grpc::CompletionQueue* new_call_cq,
			                              grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		using AsyncService = WithAsyncMethod_SetTrackerStateVector<WithAsyncMethod_UpdateTrackerVector<
			WithAsyncMethod_RefreshTrackerPoseVector<WithAsyncMethod_RequestVRRestart<WithAsyncMethod_PingDriverService<
				Service>>>>>;

		template <class BaseClass>
		class WithCallbackMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodCallback(0,
				                                  new grpc::internal::CallbackBidiHandler<
					                                  ServiceRequest, Service_TrackerStatePair>(
					                                  [this](
					                                  grpc::CallbackServerContext* context)
					                                  {
						                                  return this->SetTrackerStateVector(context);
					                                  }));
			}

			~WithCallbackMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReaderWriter<
				                                   Service_TrackerStatePair, ServiceRequest>*
			                                   /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerBidiReactor<ServiceRequest, Service_TrackerStatePair>*
			SetTrackerStateVector(
				grpc::CallbackServerContext* /*context*/)
			{
				return nullptr;
			}
		};

		template <class BaseClass>
		class WithCallbackMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodCallback(1,
				                                  new grpc::internal::CallbackBidiHandler<
					                                  ServiceRequest, Service_TrackerStatePair>(
					                                  [this](
					                                  grpc::CallbackServerContext* context)
					                                  {
						                                  return this->UpdateTrackerVector(context);
					                                  }));
			}

			~WithCallbackMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReaderWriter<
				                                 Service_TrackerStatePair, ServiceRequest>* /*stream*/
			) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerBidiReactor<ServiceRequest, Service_TrackerStatePair>*
			UpdateTrackerVector(
				grpc::CallbackServerContext* /*context*/)
			{
				return nullptr;
			}
		};

		template <class BaseClass>
		class WithCallbackMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodCallback(2,
				                                  new grpc::internal::CallbackBidiHandler<
					                                  ServiceRequest, Service_TrackerStatePair>(
					                                  [this](
					                                  grpc::CallbackServerContext* context)
					                                  {
						                                  return this->RefreshTrackerPoseVector(context);
					                                  }));
			}

			~WithCallbackMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReaderWriter<
				                                      Service_TrackerStatePair, ServiceRequest>*
			                                      /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerBidiReactor<ServiceRequest, Service_TrackerStatePair>*
			RefreshTrackerPoseVector(
				grpc::CallbackServerContext* /*context*/)
			{
				return nullptr;
			}
		};

		template <class BaseClass>
		class WithCallbackMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodCallback(3,
				                                  new grpc::internal::CallbackUnaryHandler<
					                                  ServiceRequest, Service_TrackerStatePair>(
					                                  [this](
					                                  grpc::CallbackServerContext* context,
					                                  const ServiceRequest* request,
					                                  Service_TrackerStatePair* response)
					                                  {
						                                  return this->RequestVRRestart(context, request, response);
					                                  }));
			}

			void SetMessageAllocatorFor_RequestVRRestart(
				grpc::MessageAllocator<ServiceRequest, Service_TrackerStatePair>* allocator)
			{
				grpc::internal::MethodHandler* const handler = grpc::Service::GetHandler(3);
				static_cast<grpc::internal::CallbackUnaryHandler<
						ServiceRequest, Service_TrackerStatePair>*>(handler)
					->SetMessageAllocator(allocator);
			}

			~WithCallbackMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/,
			                              const ServiceRequest* /*request*/,
			                              Service_TrackerStatePair* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* RequestVRRestart(
				grpc::CallbackServerContext* /*context*/, const ServiceRequest* /*request*/,
				Service_TrackerStatePair* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithCallbackMethod_PingDriverService : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithCallbackMethod_PingDriverService()
			{
				grpc::Service::MarkMethodCallback(4,
				                                  new grpc::internal::CallbackUnaryHandler<
					                                  google::protobuf::Empty, PingRequest>(
					                                  [this](
					                                  grpc::CallbackServerContext* context,
					                                  const google::protobuf::Empty* request,
					                                  PingRequest* response)
					                                  {
						                                  return this->PingDriverService(context, request, response);
					                                  }));
			}

			void SetMessageAllocatorFor_PingDriverService(
				grpc::MessageAllocator<google::protobuf::Empty, PingRequest>* allocator)
			{
				grpc::internal::MethodHandler* const handler = grpc::Service::GetHandler(4);
				static_cast<grpc::internal::CallbackUnaryHandler<google::protobuf::Empty, PingRequest>*>(
						handler)
					->SetMessageAllocator(allocator);
			}

			~WithCallbackMethod_PingDriverService() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status PingDriverService(grpc::ServerContext* /*context*/,
			                               const google::protobuf::Empty* /*request*/,
			                               PingRequest* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* PingDriverService(
				grpc::CallbackServerContext* /*context*/, const google::protobuf::Empty* /*request*/,
				PingRequest* /*response*/) { return nullptr; }
		};

		using CallbackService = WithCallbackMethod_SetTrackerStateVector<WithCallbackMethod_UpdateTrackerVector<
			WithCallbackMethod_RefreshTrackerPoseVector<WithCallbackMethod_RequestVRRestart<
				WithCallbackMethod_PingDriverService<Service>>>>>;
		using ExperimentalCallbackService = CallbackService;

		template <class BaseClass>
		class WithGenericMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodGeneric(0);
			}

			~WithGenericMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReaderWriter<
				                                   Service_TrackerStatePair, ServiceRequest>*
			                                   /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodGeneric(1);
			}

			~WithGenericMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReaderWriter<
				                                 Service_TrackerStatePair, ServiceRequest>* /*stream*/
			) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodGeneric(2);
			}

			~WithGenericMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReaderWriter<
				                                      Service_TrackerStatePair, ServiceRequest>*
			                                      /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodGeneric(3);
			}

			~WithGenericMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/,
			                              const ServiceRequest* /*request*/,
			                              Service_TrackerStatePair* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithGenericMethod_PingDriverService : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithGenericMethod_PingDriverService()
			{
				grpc::Service::MarkMethodGeneric(4);
			}

			~WithGenericMethod_PingDriverService() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status PingDriverService(grpc::ServerContext* /*context*/,
			                               const google::protobuf::Empty* /*request*/,
			                               PingRequest* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}
		};

		template <class BaseClass>
		class WithRawMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodRaw(0);
			}

			~WithRawMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReaderWriter<
				                                   Service_TrackerStatePair, ServiceRequest>*
			                                   /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestSetTrackerStateVector(grpc::ServerContext* context,
			                                  grpc::ServerAsyncReaderWriter<grpc::ByteBuffer, grpc::ByteBuffer>*
			                                  stream, grpc::CompletionQueue* new_call_cq,
			                                  grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodRaw(1);
			}

			~WithRawMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReaderWriter<
				                                 Service_TrackerStatePair, ServiceRequest>* /*stream*/
			) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestUpdateTrackerVector(grpc::ServerContext* context,
			                                grpc::ServerAsyncReaderWriter<grpc::ByteBuffer, grpc::ByteBuffer>*
			                                stream, grpc::CompletionQueue* new_call_cq,
			                                grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodRaw(2);
			}

			~WithRawMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReaderWriter<
				                                      Service_TrackerStatePair, ServiceRequest>*
			                                      /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRefreshTrackerPoseVector(grpc::ServerContext* context,
			                                     grpc::ServerAsyncReaderWriter<grpc::ByteBuffer, grpc::ByteBuffer>
			                                     * stream, grpc::CompletionQueue* new_call_cq,
			                                     grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodRaw(3);
			}

			~WithRawMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/,
			                              const ServiceRequest* /*request*/,
			                              Service_TrackerStatePair* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestRequestVRRestart(grpc::ServerContext* context, grpc::ByteBuffer* request,
			                             grpc::ServerAsyncResponseWriter<grpc::ByteBuffer>* response,
			                             grpc::CompletionQueue* new_call_cq,
			                             grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawMethod_PingDriverService : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawMethod_PingDriverService()
			{
				grpc::Service::MarkMethodRaw(4);
			}

			~WithRawMethod_PingDriverService() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status PingDriverService(grpc::ServerContext* /*context*/,
			                               const google::protobuf::Empty* /*request*/,
			                               PingRequest* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			void RequestPingDriverService(grpc::ServerContext* context, grpc::ByteBuffer* request,
			                              grpc::ServerAsyncResponseWriter<grpc::ByteBuffer>* response,
			                              grpc::CompletionQueue* new_call_cq,
			                              grpc::ServerCompletionQueue* notification_cq, void* tag)
			{
				grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
			}
		};

		template <class BaseClass>
		class WithRawCallbackMethod_SetTrackerStateVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_SetTrackerStateVector()
			{
				grpc::Service::MarkMethodRawCallback(0,
				                                     new grpc::internal::CallbackBidiHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context)
					                                     {
						                                     return this->SetTrackerStateVector(context);
					                                     }));
			}

			~WithRawCallbackMethod_SetTrackerStateVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status SetTrackerStateVector(grpc::ServerContext* /*context*/,
			                                   grpc::ServerReaderWriter<
				                                   Service_TrackerStatePair, ServiceRequest>*
			                                   /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerBidiReactor<grpc::ByteBuffer, grpc::ByteBuffer>* SetTrackerStateVector(
				grpc::CallbackServerContext* /*context*/)
			{
				return nullptr;
			}
		};

		template <class BaseClass>
		class WithRawCallbackMethod_UpdateTrackerVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_UpdateTrackerVector()
			{
				grpc::Service::MarkMethodRawCallback(1,
				                                     new grpc::internal::CallbackBidiHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context)
					                                     {
						                                     return this->UpdateTrackerVector(context);
					                                     }));
			}

			~WithRawCallbackMethod_UpdateTrackerVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status UpdateTrackerVector(grpc::ServerContext* /*context*/,
			                                 grpc::ServerReaderWriter<
				                                 Service_TrackerStatePair, ServiceRequest>* /*stream*/
			) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerBidiReactor<grpc::ByteBuffer, grpc::ByteBuffer>* UpdateTrackerVector(
				grpc::CallbackServerContext* /*context*/)
			{
				return nullptr;
			}
		};

		template <class BaseClass>
		class WithRawCallbackMethod_RefreshTrackerPoseVector : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_RefreshTrackerPoseVector()
			{
				grpc::Service::MarkMethodRawCallback(2,
				                                     new grpc::internal::CallbackBidiHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context)
					                                     {
						                                     return this->RefreshTrackerPoseVector(context);
					                                     }));
			}

			~WithRawCallbackMethod_RefreshTrackerPoseVector() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RefreshTrackerPoseVector(grpc::ServerContext* /*context*/,
			                                      grpc::ServerReaderWriter<
				                                      Service_TrackerStatePair, ServiceRequest>*
			                                      /*stream*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerBidiReactor<grpc::ByteBuffer, grpc::ByteBuffer>* RefreshTrackerPoseVector(
				grpc::CallbackServerContext* /*context*/)
			{
				return nullptr;
			}
		};

		template <class BaseClass>
		class WithRawCallbackMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodRawCallback(3,
				                                     new grpc::internal::CallbackUnaryHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     const grpc::ByteBuffer* request,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->
							                                     RequestVRRestart(context, request, response);
					                                     }));
			}

			~WithRawCallbackMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/,
			                              const ServiceRequest* /*request*/,
			                              Service_TrackerStatePair* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* RequestVRRestart(
				grpc::CallbackServerContext* /*context*/, const grpc::ByteBuffer* /*request*/,
				grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithRawCallbackMethod_PingDriverService : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithRawCallbackMethod_PingDriverService()
			{
				grpc::Service::MarkMethodRawCallback(4,
				                                     new grpc::internal::CallbackUnaryHandler<
					                                     grpc::ByteBuffer, grpc::ByteBuffer>(
					                                     [this](
					                                     grpc::CallbackServerContext* context,
					                                     const grpc::ByteBuffer* request,
					                                     grpc::ByteBuffer* response)
					                                     {
						                                     return this->PingDriverService(
							                                     context, request, response);
					                                     }));
			}

			~WithRawCallbackMethod_PingDriverService() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable synchronous version of this method
			grpc::Status PingDriverService(grpc::ServerContext* /*context*/,
			                               const google::protobuf::Empty* /*request*/,
			                               PingRequest* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			virtual grpc::ServerUnaryReactor* PingDriverService(
				grpc::CallbackServerContext* /*context*/, const grpc::ByteBuffer* /*request*/,
				grpc::ByteBuffer* /*response*/) { return nullptr; }
		};

		template <class BaseClass>
		class WithStreamedUnaryMethod_RequestVRRestart : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithStreamedUnaryMethod_RequestVRRestart()
			{
				grpc::Service::MarkMethodStreamed(3,
				                                  new grpc::internal::StreamedUnaryHandler<
					                                  ServiceRequest, Service_TrackerStatePair>(
					                                  [this](grpc::ServerContext* context,
					                                         grpc::ServerUnaryStreamer<
						                                         ServiceRequest,
						                                         Service_TrackerStatePair>* streamer)
					                                  {
						                                  return this->StreamedRequestVRRestart(context,
							                                  streamer);
					                                  }));
			}

			~WithStreamedUnaryMethod_RequestVRRestart() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable regular version of this method
			grpc::Status RequestVRRestart(grpc::ServerContext* /*context*/,
			                              const ServiceRequest* /*request*/,
			                              Service_TrackerStatePair* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			// replace default version of method with streamed unary
			virtual grpc::Status StreamedRequestVRRestart(grpc::ServerContext* context,
			                                              grpc::ServerUnaryStreamer<
				                                              ServiceRequest,
				                                              Service_TrackerStatePair>*
			                                              server_unary_streamer) = 0;
		};

		template <class BaseClass>
		class WithStreamedUnaryMethod_PingDriverService : public BaseClass
		{
		private:
			void BaseClassMustBeDerivedFromService(const Service* /*service*/)
			{
			}

		public:
			WithStreamedUnaryMethod_PingDriverService()
			{
				grpc::Service::MarkMethodStreamed(4,
				                                  new grpc::internal::StreamedUnaryHandler<
					                                  google::protobuf::Empty, PingRequest>(
					                                  [this](grpc::ServerContext* context,
					                                         grpc::ServerUnaryStreamer<
						                                         google::protobuf::Empty, PingRequest>*
					                                         streamer)
					                                  {
						                                  return this->StreamedPingDriverService(context,
							                                  streamer);
					                                  }));
			}

			~WithStreamedUnaryMethod_PingDriverService() override
			{
				BaseClassMustBeDerivedFromService(this);
			}

			// disable regular version of this method
			grpc::Status PingDriverService(grpc::ServerContext* /*context*/,
			                               const google::protobuf::Empty* /*request*/,
			                               PingRequest* /*response*/) override
			{
				abort();
				return grpc::Status(grpc::StatusCode::UNIMPLEMENTED, "");
			}

			// replace default version of method with streamed unary
			virtual grpc::Status StreamedPingDriverService(grpc::ServerContext* context,
			                                               grpc::ServerUnaryStreamer<
				                                               google::protobuf::Empty, PingRequest>*
			                                               server_unary_streamer) = 0;
		};

		using StreamedUnaryService = WithStreamedUnaryMethod_RequestVRRestart<WithStreamedUnaryMethod_PingDriverService<
			Service>>;
		using SplitStreamedService = Service;
		using StreamedService = WithStreamedUnaryMethod_RequestVRRestart<WithStreamedUnaryMethod_PingDriverService<
			Service>>;
	};
} // namespace ktvr


#endif  // GRPC_Amethyst_5fAPI_2eproto__INCLUDED
