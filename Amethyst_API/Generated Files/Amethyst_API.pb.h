// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Amethyst_API.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Amethyst_5fAPI_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Amethyst_5fAPI_2eproto

#ifdef AMETHYST_API_EXPORTS
#define KTVR_API __declspec(dllexport)
#else
#define KTVR_API __declspec(dllimport)
#endif

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Amethyst_5fAPI_2eproto KTVR_API
PROTOBUF_NAMESPACE_OPEN
	namespace internal
	{
		class AnyMetadata;
	} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct KTVR_API TableStruct_Amethyst_5fAPI_2eproto
{
	static const uint32_t offsets[];
};

KTVR_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Amethyst_5fAPI_2eproto;

namespace ktvr
{
	class K2Message;
	struct K2MessageDefaultTypeInternal;
	KTVR_API extern K2MessageDefaultTypeInternal _K2Message_default_instance_;
	class K2Quaternion;
	struct K2QuaternionDefaultTypeInternal;
	KTVR_API extern K2QuaternionDefaultTypeInternal _K2Quaternion_default_instance_;
	class K2ResponseMessage;
	struct K2ResponseMessageDefaultTypeInternal;
	KTVR_API extern K2ResponseMessageDefaultTypeInternal _K2ResponseMessage_default_instance_;
	class K2StatusPair;
	struct K2StatusPairDefaultTypeInternal;
	KTVR_API extern K2StatusPairDefaultTypeInternal _K2StatusPair_default_instance_;
	class K2TrackerBase;
	struct K2TrackerBaseDefaultTypeInternal;
	KTVR_API extern K2TrackerBaseDefaultTypeInternal _K2TrackerBase_default_instance_;
	class K2TrackerData;
	struct K2TrackerDataDefaultTypeInternal;
	KTVR_API extern K2TrackerDataDefaultTypeInternal _K2TrackerData_default_instance_;
	class K2TrackerPhysics;
	struct K2TrackerPhysicsDefaultTypeInternal;
	KTVR_API extern K2TrackerPhysicsDefaultTypeInternal _K2TrackerPhysics_default_instance_;
	class K2TrackerPose;
	struct K2TrackerPoseDefaultTypeInternal;
	KTVR_API extern K2TrackerPoseDefaultTypeInternal _K2TrackerPose_default_instance_;
	class K2Vector3;
	struct K2Vector3DefaultTypeInternal;
	KTVR_API extern K2Vector3DefaultTypeInternal _K2Vector3_default_instance_;
	class ServiceRequest;
	struct ServiceRequestDefaultTypeInternal;
	KTVR_API extern ServiceRequestDefaultTypeInternal _ServiceRequest_default_instance_;
	class Service_SetTrackerStateRequest;
	struct Service_SetTrackerStateRequestDefaultTypeInternal;
	KTVR_API extern Service_SetTrackerStateRequestDefaultTypeInternal _Service_SetTrackerStateRequest_default_instance_;
} // namespace ktvr
PROTOBUF_NAMESPACE_OPEN
	template <>
	KTVR_API ktvr::K2Message* Arena::CreateMaybeMessage<ktvr::K2Message>(Arena*);
	template <>
	KTVR_API ktvr::K2Quaternion* Arena::CreateMaybeMessage<ktvr::K2Quaternion>(Arena*);
	template <>
	KTVR_API ktvr::K2ResponseMessage* Arena::CreateMaybeMessage<ktvr::K2ResponseMessage>(Arena*);
	template <>
	KTVR_API ktvr::K2StatusPair* Arena::CreateMaybeMessage<ktvr::K2StatusPair>(Arena*);
	template <>
	KTVR_API ktvr::K2TrackerBase* Arena::CreateMaybeMessage<ktvr::K2TrackerBase>(Arena*);
	template <>
	KTVR_API ktvr::K2TrackerData* Arena::CreateMaybeMessage<ktvr::K2TrackerData>(Arena*);
	template <>
	KTVR_API ktvr::K2TrackerPhysics* Arena::CreateMaybeMessage<ktvr::K2TrackerPhysics>(Arena*);
	template <>
	KTVR_API ktvr::K2TrackerPose* Arena::CreateMaybeMessage<ktvr::K2TrackerPose>(Arena*);
	template <>
	KTVR_API ktvr::K2Vector3* Arena::CreateMaybeMessage<ktvr::K2Vector3>(Arena*);
	template <>
	KTVR_API ktvr::ServiceRequest* Arena::CreateMaybeMessage<ktvr::ServiceRequest>(Arena*);
	template <>
	KTVR_API ktvr::Service_SetTrackerStateRequest* Arena::CreateMaybeMessage<
		ktvr::Service_SetTrackerStateRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace ktvr
{
	enum ITrackerType : int
	{
		Tracker_Handed = 0,
		Tracker_LeftFoot = 1,
		Tracker_RightFoot = 2,
		Tracker_LeftShoulder = 3,
		Tracker_RightShoulder = 4,
		Tracker_LeftElbow = 5,
		Tracker_RightElbow = 6,
		Tracker_LeftKnee = 7,
		Tracker_RightKnee = 8,
		Tracker_Waist = 9,
		Tracker_Chest = 10,
		Tracker_Camera = 11,
		Tracker_Keyboard = 12,
		ITrackerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
		ITrackerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
	};

	KTVR_API bool ITrackerType_IsValid(int value);
	constexpr ITrackerType ITrackerType_MIN = Tracker_Handed;
	constexpr ITrackerType ITrackerType_MAX = Tracker_Keyboard;
	constexpr int ITrackerType_ARRAYSIZE = ITrackerType_MAX + 1;

	KTVR_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ITrackerType_descriptor();

	template <typename T>
	const std::string& ITrackerType_Name(T enum_t_value)
	{
		static_assert(std::is_same_v<T, ITrackerType> ||
			std::is_integral_v<T>,
			"Incorrect type passed to function ITrackerType_Name.");
		return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
			ITrackerType_descriptor(), enum_t_value);
	}

	inline bool ITrackerType_Parse(
		::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ITrackerType* value)
	{
		return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ITrackerType>(
			ITrackerType_descriptor(), name, value);
	}

	enum K2MessageType : int
	{
		K2Message_Invalid = 0,
		K2Message_SetTrackerState = 1,
		K2Message_SetTrackerStateVector = 2,
		K2Message_SetStateAll = 3,
		K2Message_UpdateTrackerPose = 4,
		K2Message_UpdateTrackerPoseVector = 5,
		K2Message_RefreshTracker = 6,
		K2Message_RequestRestart = 7,
		K2Message_Ping = 8,
		K2MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
		K2MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
	};

	KTVR_API bool K2MessageType_IsValid(int value);
	constexpr K2MessageType K2MessageType_MIN = K2Message_Invalid;
	constexpr K2MessageType K2MessageType_MAX = K2Message_Ping;
	constexpr int K2MessageType_ARRAYSIZE = K2MessageType_MAX + 1;

	KTVR_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K2MessageType_descriptor();

	template <typename T>
	const std::string& K2MessageType_Name(T enum_t_value)
	{
		static_assert(std::is_same_v<T, K2MessageType> ||
			std::is_integral_v<T>,
			"Incorrect type passed to function K2MessageType_Name.");
		return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
			K2MessageType_descriptor(), enum_t_value);
	}

	inline bool K2MessageType_Parse(
		::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K2MessageType* value)
	{
		return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K2MessageType>(
			K2MessageType_descriptor(), name, value);
	}

	enum K2ResponseMessageType : int
	{
		K2ResponseMessage_Invalid = 0,
		K2ResponseMessage_Role = 1,
		K2ResponseMessage_Success = 2,
		K2ResponseMessage_Tracker = 3,
		K2ResponseMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
		K2ResponseMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
	};

	KTVR_API bool K2ResponseMessageType_IsValid(int value);
	constexpr K2ResponseMessageType K2ResponseMessageType_MIN = K2ResponseMessage_Invalid;
	constexpr K2ResponseMessageType K2ResponseMessageType_MAX = K2ResponseMessage_Tracker;
	constexpr int K2ResponseMessageType_ARRAYSIZE = K2ResponseMessageType_MAX + 1;

	KTVR_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K2ResponseMessageType_descriptor();

	template <typename T>
	const std::string& K2ResponseMessageType_Name(T enum_t_value)
	{
		static_assert(std::is_same_v<T, K2ResponseMessageType> ||
			std::is_integral_v<T>,
			"Incorrect type passed to function K2ResponseMessageType_Name.");
		return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
			K2ResponseMessageType_descriptor(), enum_t_value);
	}

	inline bool K2ResponseMessageType_Parse(
		::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K2ResponseMessageType* value)
	{
		return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K2ResponseMessageType>(
			K2ResponseMessageType_descriptor(), name, value);
	}

	enum K2ResponseMessageCode : int
	{
		K2ResponseMessageCode_Exception = 0,
		K2ResponseMessageCode_UnknownError = 1,
		K2ResponseMessageCode_Invalid = 2,
		K2ResponseMessageCode_OK = 3,
		K2ResponseMessageCode_SpawnFailed = 4,
		K2ResponseMessageCode_AlreadyPresent = 5,
		K2ResponseMessageCode_BadRequest = 6,
		K2ResponseMessageCode_ParsingError = 7,
		K2ResponseMessageCode_BadSerial = 8,
		K2ResponseMessageCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
		K2ResponseMessageCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
	};

	KTVR_API bool K2ResponseMessageCode_IsValid(int value);
	constexpr K2ResponseMessageCode K2ResponseMessageCode_MIN = K2ResponseMessageCode_Exception;
	constexpr K2ResponseMessageCode K2ResponseMessageCode_MAX = K2ResponseMessageCode_BadSerial;
	constexpr int K2ResponseMessageCode_ARRAYSIZE = K2ResponseMessageCode_MAX + 1;

	KTVR_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* K2ResponseMessageCode_descriptor();

	template <typename T>
	const std::string& K2ResponseMessageCode_Name(T enum_t_value)
	{
		static_assert(std::is_same_v<T, K2ResponseMessageCode> ||
			std::is_integral_v<T>,
			"Incorrect type passed to function K2ResponseMessageCode_Name.");
		return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
			K2ResponseMessageCode_descriptor(), enum_t_value);
	}

	inline bool K2ResponseMessageCode_Parse(
		::PROTOBUF_NAMESPACE_ID::ConstStringParam name, K2ResponseMessageCode* value)
	{
		return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<K2ResponseMessageCode>(
			K2ResponseMessageCode_descriptor(), name, value);
	}

	// ===================================================================

	class KTVR_API ServiceRequest final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.ServiceRequest) */
	{
	public:
		ServiceRequest() : ServiceRequest(nullptr)
		{
		}

		~ServiceRequest() override;
		explicit PROTOBUF_CONSTEXPR ServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		ServiceRequest(const ServiceRequest& from);

		ServiceRequest(ServiceRequest&& from) noexcept
			: ServiceRequest()
		{
			*this = std::move(from);
		}

		ServiceRequest& operator=(const ServiceRequest& from)
		{
			CopyFrom(from);
			return *this;
		}

		ServiceRequest& operator=(ServiceRequest&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const ServiceRequest& default_instance()
		{
			return *internal_default_instance();
		}

		enum ValueOneofCase
		{
			kTrackerStateTuple = 1,
			kTrackerBase = 2,
			kMessage = 3,
			VALUE_ONEOF_NOT_SET = 0,
		};

		static const ServiceRequest* internal_default_instance()
		{
			return reinterpret_cast<const ServiceRequest*>(
				&_ServiceRequest_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			0;

		friend void swap(ServiceRequest& a, ServiceRequest& b)
		{
			a.Swap(&b);
		}

		void Swap(ServiceRequest* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(ServiceRequest* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		ServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<ServiceRequest>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const ServiceRequest& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const ServiceRequest& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(ServiceRequest* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.ServiceRequest";
		}

	protected:
		explicit ServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                        bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kTrackerStateTupleFieldNumber = 1,
			kTrackerBaseFieldNumber = 2,
			kMessageFieldNumber = 3,
		};

		// .ktvr.Service_SetTrackerStateRequest trackerStateTuple = 1;
		bool has_trackerstatetuple() const;

	private:
		bool _internal_has_trackerstatetuple() const;

	public:
		void clear_trackerstatetuple();
		const Service_SetTrackerStateRequest& trackerstatetuple() const;
		PROTOBUF_NODISCARD Service_SetTrackerStateRequest* release_trackerstatetuple();
		Service_SetTrackerStateRequest* mutable_trackerstatetuple();
		void set_allocated_trackerstatetuple(Service_SetTrackerStateRequest* trackerstatetuple);

	private:
		const Service_SetTrackerStateRequest& _internal_trackerstatetuple() const;
		Service_SetTrackerStateRequest* _internal_mutable_trackerstatetuple();

	public:
		void unsafe_arena_set_allocated_trackerstatetuple(
			Service_SetTrackerStateRequest* trackerstatetuple);
		Service_SetTrackerStateRequest* unsafe_arena_release_trackerstatetuple();

		// .ktvr.K2TrackerBase trackerBase = 2;
		bool has_trackerbase() const;

	private:
		bool _internal_has_trackerbase() const;

	public:
		void clear_trackerbase();
		const K2TrackerBase& trackerbase() const;
		PROTOBUF_NODISCARD K2TrackerBase* release_trackerbase();
		K2TrackerBase* mutable_trackerbase();
		void set_allocated_trackerbase(K2TrackerBase* trackerbase);

	private:
		const K2TrackerBase& _internal_trackerbase() const;
		K2TrackerBase* _internal_mutable_trackerbase();

	public:
		void unsafe_arena_set_allocated_trackerbase(
			K2TrackerBase* trackerbase);
		K2TrackerBase* unsafe_arena_release_trackerbase();

		// string message = 3;
		bool has_message() const;

	private:
		bool _internal_has_message() const;

	public:
		void clear_message();
		const std::string& message() const;
		template <typename ArgT0 = const std::string&, typename... ArgT>
		void set_message(ArgT0&& arg0, ArgT... args);
		std::string* mutable_message();
		PROTOBUF_NODISCARD std::string* release_message();
		void set_allocated_message(std::string* message);

	private:
		const std::string& _internal_message() const;
		inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
		std::string* _internal_mutable_message();

	public:
		void clear_value_oneof();
		ValueOneofCase value_oneof_case() const;
		// @@protoc_insertion_point(class_scope:ktvr.ServiceRequest)
	private:
		class _Internal;
		void set_has_trackerstatetuple();
		void set_has_trackerbase();
		void set_has_message();

		inline bool has_value_oneof() const;
		inline void clear_has_value_oneof();

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			union ValueOneofUnion
			{
				constexpr ValueOneofUnion() : _constinit_{}
				{
				}

				::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
				Service_SetTrackerStateRequest* trackerstatetuple_;
				K2TrackerBase* trackerbase_;
				::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
			} value_oneof_;

			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
			uint32_t _oneof_case_[1];
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API Service_SetTrackerStateRequest final :
		public ::PROTOBUF_NAMESPACE_ID::Message
		/* @@protoc_insertion_point(class_definition:ktvr.Service_SetTrackerStateRequest) */
	{
	public:
		Service_SetTrackerStateRequest() : Service_SetTrackerStateRequest(nullptr)
		{
		}

		~Service_SetTrackerStateRequest() override;
		explicit PROTOBUF_CONSTEXPR Service_SetTrackerStateRequest(
			::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		Service_SetTrackerStateRequest(const Service_SetTrackerStateRequest& from);

		Service_SetTrackerStateRequest(Service_SetTrackerStateRequest&& from) noexcept
			: Service_SetTrackerStateRequest()
		{
			*this = std::move(from);
		}

		Service_SetTrackerStateRequest& operator=(const Service_SetTrackerStateRequest& from)
		{
			CopyFrom(from);
			return *this;
		}

		Service_SetTrackerStateRequest& operator=(Service_SetTrackerStateRequest&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const Service_SetTrackerStateRequest& default_instance()
		{
			return *internal_default_instance();
		}

		static const Service_SetTrackerStateRequest* internal_default_instance()
		{
			return reinterpret_cast<const Service_SetTrackerStateRequest*>(
				&_Service_SetTrackerStateRequest_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			1;

		friend void swap(Service_SetTrackerStateRequest& a, Service_SetTrackerStateRequest& b)
		{
			a.Swap(&b);
		}

		void Swap(Service_SetTrackerStateRequest* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(Service_SetTrackerStateRequest* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		Service_SetTrackerStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<Service_SetTrackerStateRequest>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const Service_SetTrackerStateRequest& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const Service_SetTrackerStateRequest& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(Service_SetTrackerStateRequest* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.Service_SetTrackerStateRequest";
		}

	protected:
		explicit Service_SetTrackerStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                                        bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kTrackerTypeFieldNumber = 1,
			kStateFieldNumber = 2,
		};

		// .ktvr.ITrackerType trackerType = 1;
		void clear_trackertype();
		ITrackerType trackertype() const;
		void set_trackertype(ITrackerType value);

	private:
		ITrackerType _internal_trackertype() const;
		void _internal_set_trackertype(ITrackerType value);

	public:
		// bool state = 2;
		void clear_state();
		bool state() const;
		void set_state(bool value);

	private:
		bool _internal_state() const;
		void _internal_set_state(bool value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.Service_SetTrackerStateRequest)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			int trackertype_;
			bool state_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2Quaternion final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2Quaternion) */
	{
	public:
		K2Quaternion() : K2Quaternion(nullptr)
		{
		}

		~K2Quaternion() override;
		explicit PROTOBUF_CONSTEXPR K2Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2Quaternion(const K2Quaternion& from);

		K2Quaternion(K2Quaternion&& from) noexcept
			: K2Quaternion()
		{
			*this = std::move(from);
		}

		K2Quaternion& operator=(const K2Quaternion& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2Quaternion& operator=(K2Quaternion&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2Quaternion& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2Quaternion* internal_default_instance()
		{
			return reinterpret_cast<const K2Quaternion*>(
				&_K2Quaternion_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			2;

		friend void swap(K2Quaternion& a, K2Quaternion& b)
		{
			a.Swap(&b);
		}

		void Swap(K2Quaternion* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2Quaternion* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2Quaternion>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2Quaternion& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2Quaternion& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2Quaternion* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2Quaternion";
		}

	protected:
		explicit K2Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                      bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kWFieldNumber = 1,
			kXFieldNumber = 2,
			kYFieldNumber = 3,
			kZFieldNumber = 4,
		};

		// double w = 1;
		void clear_w();
		double w() const;
		void set_w(double value);

	private:
		double _internal_w() const;
		void _internal_set_w(double value);

	public:
		// double x = 2;
		void clear_x();
		double x() const;
		void set_x(double value);

	private:
		double _internal_x() const;
		void _internal_set_x(double value);

	public:
		// double y = 3;
		void clear_y();
		double y() const;
		void set_y(double value);

	private:
		double _internal_y() const;
		void _internal_set_y(double value);

	public:
		// double z = 4;
		void clear_z();
		double z() const;
		void set_z(double value);

	private:
		double _internal_z() const;
		void _internal_set_z(double value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2Quaternion)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			double w_;
			double x_;
			double y_;
			double z_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2Vector3 final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2Vector3) */
	{
	public:
		K2Vector3() : K2Vector3(nullptr)
		{
		}

		~K2Vector3() override;
		explicit PROTOBUF_CONSTEXPR K2Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2Vector3(const K2Vector3& from);

		K2Vector3(K2Vector3&& from) noexcept
			: K2Vector3()
		{
			*this = std::move(from);
		}

		K2Vector3& operator=(const K2Vector3& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2Vector3& operator=(K2Vector3&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2Vector3& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2Vector3* internal_default_instance()
		{
			return reinterpret_cast<const K2Vector3*>(
				&_K2Vector3_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			3;

		friend void swap(K2Vector3& a, K2Vector3& b)
		{
			a.Swap(&b);
		}

		void Swap(K2Vector3* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2Vector3* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2Vector3>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2Vector3& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2Vector3& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2Vector3* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2Vector3";
		}

	protected:
		explicit K2Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                   bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kXFieldNumber = 1,
			kYFieldNumber = 2,
			kZFieldNumber = 3,
		};

		// double x = 1;
		void clear_x();
		double x() const;
		void set_x(double value);

	private:
		double _internal_x() const;
		void _internal_set_x(double value);

	public:
		// double y = 2;
		void clear_y();
		double y() const;
		void set_y(double value);

	private:
		double _internal_y() const;
		void _internal_set_y(double value);

	public:
		// double z = 3;
		void clear_z();
		double z() const;
		void set_z(double value);

	private:
		double _internal_z() const;
		void _internal_set_z(double value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2Vector3)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			double x_;
			double y_;
			double z_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2TrackerPhysics final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2TrackerPhysics) */
	{
	public:
		K2TrackerPhysics() : K2TrackerPhysics(nullptr)
		{
		}

		~K2TrackerPhysics() override;
		explicit PROTOBUF_CONSTEXPR K2TrackerPhysics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2TrackerPhysics(const K2TrackerPhysics& from);

		K2TrackerPhysics(K2TrackerPhysics&& from) noexcept
			: K2TrackerPhysics()
		{
			*this = std::move(from);
		}

		K2TrackerPhysics& operator=(const K2TrackerPhysics& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2TrackerPhysics& operator=(K2TrackerPhysics&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2TrackerPhysics& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2TrackerPhysics* internal_default_instance()
		{
			return reinterpret_cast<const K2TrackerPhysics*>(
				&_K2TrackerPhysics_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			4;

		friend void swap(K2TrackerPhysics& a, K2TrackerPhysics& b)
		{
			a.Swap(&b);
		}

		void Swap(K2TrackerPhysics* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2TrackerPhysics* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2TrackerPhysics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2TrackerPhysics>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2TrackerPhysics& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2TrackerPhysics& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2TrackerPhysics* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2TrackerPhysics";
		}

	protected:
		explicit K2TrackerPhysics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                          bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kVelocityFieldNumber = 1,
			kAccelerationFieldNumber = 2,
			kAngularVelocityFieldNumber = 3,
			kAngularAccelerationFieldNumber = 4,
		};

		// .ktvr.K2Vector3 velocity = 1;
		bool has_velocity() const;

	private:
		bool _internal_has_velocity() const;

	public:
		void clear_velocity();
		const K2Vector3& velocity() const;
		PROTOBUF_NODISCARD K2Vector3* release_velocity();
		K2Vector3* mutable_velocity();
		void set_allocated_velocity(K2Vector3* velocity);

	private:
		const K2Vector3& _internal_velocity() const;
		K2Vector3* _internal_mutable_velocity();

	public:
		void unsafe_arena_set_allocated_velocity(
			K2Vector3* velocity);
		K2Vector3* unsafe_arena_release_velocity();

		// .ktvr.K2Vector3 acceleration = 2;
		bool has_acceleration() const;

	private:
		bool _internal_has_acceleration() const;

	public:
		void clear_acceleration();
		const K2Vector3& acceleration() const;
		PROTOBUF_NODISCARD K2Vector3* release_acceleration();
		K2Vector3* mutable_acceleration();
		void set_allocated_acceleration(K2Vector3* acceleration);

	private:
		const K2Vector3& _internal_acceleration() const;
		K2Vector3* _internal_mutable_acceleration();

	public:
		void unsafe_arena_set_allocated_acceleration(
			K2Vector3* acceleration);
		K2Vector3* unsafe_arena_release_acceleration();

		// .ktvr.K2Vector3 angularVelocity = 3;
		bool has_angularvelocity() const;

	private:
		bool _internal_has_angularvelocity() const;

	public:
		void clear_angularvelocity();
		const K2Vector3& angularvelocity() const;
		PROTOBUF_NODISCARD K2Vector3* release_angularvelocity();
		K2Vector3* mutable_angularvelocity();
		void set_allocated_angularvelocity(K2Vector3* angularvelocity);

	private:
		const K2Vector3& _internal_angularvelocity() const;
		K2Vector3* _internal_mutable_angularvelocity();

	public:
		void unsafe_arena_set_allocated_angularvelocity(
			K2Vector3* angularvelocity);
		K2Vector3* unsafe_arena_release_angularvelocity();

		// .ktvr.K2Vector3 angularAcceleration = 4;
		bool has_angularacceleration() const;

	private:
		bool _internal_has_angularacceleration() const;

	public:
		void clear_angularacceleration();
		const K2Vector3& angularacceleration() const;
		PROTOBUF_NODISCARD K2Vector3* release_angularacceleration();
		K2Vector3* mutable_angularacceleration();
		void set_allocated_angularacceleration(K2Vector3* angularacceleration);

	private:
		const K2Vector3& _internal_angularacceleration() const;
		K2Vector3* _internal_mutable_angularacceleration();

	public:
		void unsafe_arena_set_allocated_angularacceleration(
			K2Vector3* angularacceleration);
		K2Vector3* unsafe_arena_release_angularacceleration();

		// @@protoc_insertion_point(class_scope:ktvr.K2TrackerPhysics)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			K2Vector3* velocity_;
			K2Vector3* acceleration_;
			K2Vector3* angularvelocity_;
			K2Vector3* angularacceleration_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2TrackerPose final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2TrackerPose) */
	{
	public:
		K2TrackerPose() : K2TrackerPose(nullptr)
		{
		}

		~K2TrackerPose() override;
		explicit PROTOBUF_CONSTEXPR K2TrackerPose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2TrackerPose(const K2TrackerPose& from);

		K2TrackerPose(K2TrackerPose&& from) noexcept
			: K2TrackerPose()
		{
			*this = std::move(from);
		}

		K2TrackerPose& operator=(const K2TrackerPose& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2TrackerPose& operator=(K2TrackerPose&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2TrackerPose& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2TrackerPose* internal_default_instance()
		{
			return reinterpret_cast<const K2TrackerPose*>(
				&_K2TrackerPose_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			5;

		friend void swap(K2TrackerPose& a, K2TrackerPose& b)
		{
			a.Swap(&b);
		}

		void Swap(K2TrackerPose* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2TrackerPose* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2TrackerPose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2TrackerPose>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2TrackerPose& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2TrackerPose& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2TrackerPose* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2TrackerPose";
		}

	protected:
		explicit K2TrackerPose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                       bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kOrientationFieldNumber = 1,
			kPositionFieldNumber = 2,
			kPhysicsFieldNumber = 3,
		};

		// .ktvr.K2Quaternion orientation = 1;
		bool has_orientation() const;

	private:
		bool _internal_has_orientation() const;

	public:
		void clear_orientation();
		const K2Quaternion& orientation() const;
		PROTOBUF_NODISCARD K2Quaternion* release_orientation();
		K2Quaternion* mutable_orientation();
		void set_allocated_orientation(K2Quaternion* orientation);

	private:
		const K2Quaternion& _internal_orientation() const;
		K2Quaternion* _internal_mutable_orientation();

	public:
		void unsafe_arena_set_allocated_orientation(
			K2Quaternion* orientation);
		K2Quaternion* unsafe_arena_release_orientation();

		// .ktvr.K2Vector3 position = 2;
		bool has_position() const;

	private:
		bool _internal_has_position() const;

	public:
		void clear_position();
		const K2Vector3& position() const;
		PROTOBUF_NODISCARD K2Vector3* release_position();
		K2Vector3* mutable_position();
		void set_allocated_position(K2Vector3* position);

	private:
		const K2Vector3& _internal_position() const;
		K2Vector3* _internal_mutable_position();

	public:
		void unsafe_arena_set_allocated_position(
			K2Vector3* position);
		K2Vector3* unsafe_arena_release_position();

		// optional .ktvr.K2TrackerPhysics physics = 3;
		bool has_physics() const;

	private:
		bool _internal_has_physics() const;

	public:
		void clear_physics();
		const K2TrackerPhysics& physics() const;
		PROTOBUF_NODISCARD K2TrackerPhysics* release_physics();
		K2TrackerPhysics* mutable_physics();
		void set_allocated_physics(K2TrackerPhysics* physics);

	private:
		const K2TrackerPhysics& _internal_physics() const;
		K2TrackerPhysics* _internal_mutable_physics();

	public:
		void unsafe_arena_set_allocated_physics(
			K2TrackerPhysics* physics);
		K2TrackerPhysics* unsafe_arena_release_physics();

		// @@protoc_insertion_point(class_scope:ktvr.K2TrackerPose)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
			K2Quaternion* orientation_;
			K2Vector3* position_;
			K2TrackerPhysics* physics_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2StatusPair final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2StatusPair) */
	{
	public:
		K2StatusPair() : K2StatusPair(nullptr)
		{
		}

		~K2StatusPair() override;
		explicit PROTOBUF_CONSTEXPR K2StatusPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2StatusPair(const K2StatusPair& from);

		K2StatusPair(K2StatusPair&& from) noexcept
			: K2StatusPair()
		{
			*this = std::move(from);
		}

		K2StatusPair& operator=(const K2StatusPair& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2StatusPair& operator=(K2StatusPair&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2StatusPair& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2StatusPair* internal_default_instance()
		{
			return reinterpret_cast<const K2StatusPair*>(
				&_K2StatusPair_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			6;

		friend void swap(K2StatusPair& a, K2StatusPair& b)
		{
			a.Swap(&b);
		}

		void Swap(K2StatusPair* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2StatusPair* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2StatusPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2StatusPair>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2StatusPair& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2StatusPair& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2StatusPair* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2StatusPair";
		}

	protected:
		explicit K2StatusPair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                      bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kTrackerFieldNumber = 1,
			kStatusFieldNumber = 2,
		};

		// .ktvr.ITrackerType tracker = 1;
		void clear_tracker();
		ITrackerType tracker() const;
		void set_tracker(ITrackerType value);

	private:
		ITrackerType _internal_tracker() const;
		void _internal_set_tracker(ITrackerType value);

	public:
		// bool status = 2;
		void clear_status();
		bool status() const;
		void set_status(bool value);

	private:
		bool _internal_status() const;
		void _internal_set_status(bool value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2StatusPair)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			int tracker_;
			bool status_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2TrackerData final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2TrackerData) */
	{
	public:
		K2TrackerData() : K2TrackerData(nullptr)
		{
		}

		~K2TrackerData() override;
		explicit PROTOBUF_CONSTEXPR K2TrackerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2TrackerData(const K2TrackerData& from);

		K2TrackerData(K2TrackerData&& from) noexcept
			: K2TrackerData()
		{
			*this = std::move(from);
		}

		K2TrackerData& operator=(const K2TrackerData& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2TrackerData& operator=(K2TrackerData&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2TrackerData& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2TrackerData* internal_default_instance()
		{
			return reinterpret_cast<const K2TrackerData*>(
				&_K2TrackerData_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			7;

		friend void swap(K2TrackerData& a, K2TrackerData& b)
		{
			a.Swap(&b);
		}

		void Swap(K2TrackerData* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2TrackerData* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2TrackerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2TrackerData>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2TrackerData& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2TrackerData& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2TrackerData* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2TrackerData";
		}

	protected:
		explicit K2TrackerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                       bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kSerialFieldNumber = 1,
			kRoleFieldNumber = 2,
			kIsActiveFieldNumber = 3,
		};

		// string serial = 1;
		void clear_serial();
		const std::string& serial() const;
		template <typename ArgT0 = const std::string&, typename... ArgT>
		void set_serial(ArgT0&& arg0, ArgT... args);
		std::string* mutable_serial();
		PROTOBUF_NODISCARD std::string* release_serial();
		void set_allocated_serial(std::string* serial);

	private:
		const std::string& _internal_serial() const;
		inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
		std::string* _internal_mutable_serial();

	public:
		// .ktvr.ITrackerType role = 2;
		void clear_role();
		ITrackerType role() const;
		void set_role(ITrackerType value);

	private:
		ITrackerType _internal_role() const;
		void _internal_set_role(ITrackerType value);

	public:
		// bool isActive = 3;
		void clear_isactive();
		bool isactive() const;
		void set_isactive(bool value);

	private:
		bool _internal_isactive() const;
		void _internal_set_isactive(bool value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2TrackerData)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
			int role_;
			bool isactive_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2TrackerBase final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2TrackerBase) */
	{
	public:
		K2TrackerBase() : K2TrackerBase(nullptr)
		{
		}

		~K2TrackerBase() override;
		explicit PROTOBUF_CONSTEXPR K2TrackerBase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2TrackerBase(const K2TrackerBase& from);

		K2TrackerBase(K2TrackerBase&& from) noexcept
			: K2TrackerBase()
		{
			*this = std::move(from);
		}

		K2TrackerBase& operator=(const K2TrackerBase& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2TrackerBase& operator=(K2TrackerBase&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2TrackerBase& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2TrackerBase* internal_default_instance()
		{
			return reinterpret_cast<const K2TrackerBase*>(
				&_K2TrackerBase_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			8;

		friend void swap(K2TrackerBase& a, K2TrackerBase& b)
		{
			a.Swap(&b);
		}

		void Swap(K2TrackerBase* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2TrackerBase* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2TrackerBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2TrackerBase>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2TrackerBase& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2TrackerBase& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2TrackerBase* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2TrackerBase";
		}

	protected:
		explicit K2TrackerBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                       bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kPoseFieldNumber = 1,
			kDataFieldNumber = 2,
			kTrackerFieldNumber = 3,
		};

		// .ktvr.K2TrackerPose pose = 1;
		bool has_pose() const;

	private:
		bool _internal_has_pose() const;

	public:
		void clear_pose();
		const K2TrackerPose& pose() const;
		PROTOBUF_NODISCARD K2TrackerPose* release_pose();
		K2TrackerPose* mutable_pose();
		void set_allocated_pose(K2TrackerPose* pose);

	private:
		const K2TrackerPose& _internal_pose() const;
		K2TrackerPose* _internal_mutable_pose();

	public:
		void unsafe_arena_set_allocated_pose(
			K2TrackerPose* pose);
		K2TrackerPose* unsafe_arena_release_pose();

		// .ktvr.K2TrackerData data = 2;
		bool has_data() const;

	private:
		bool _internal_has_data() const;

	public:
		void clear_data();
		const K2TrackerData& data() const;
		PROTOBUF_NODISCARD K2TrackerData* release_data();
		K2TrackerData* mutable_data();
		void set_allocated_data(K2TrackerData* data);

	private:
		const K2TrackerData& _internal_data() const;
		K2TrackerData* _internal_mutable_data();

	public:
		void unsafe_arena_set_allocated_data(
			K2TrackerData* data);
		K2TrackerData* unsafe_arena_release_data();

		// .ktvr.ITrackerType tracker = 3;
		void clear_tracker();
		ITrackerType tracker() const;
		void set_tracker(ITrackerType value);

	private:
		ITrackerType _internal_tracker() const;
		void _internal_set_tracker(ITrackerType value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2TrackerBase)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			K2TrackerPose* pose_;
			K2TrackerData* data_;
			int tracker_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2Message final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2Message) */
	{
	public:
		K2Message() : K2Message(nullptr)
		{
		}

		~K2Message() override;
		explicit PROTOBUF_CONSTEXPR K2Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2Message(const K2Message& from);

		K2Message(K2Message&& from) noexcept
			: K2Message()
		{
			*this = std::move(from);
		}

		K2Message& operator=(const K2Message& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2Message& operator=(K2Message&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2Message& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2Message* internal_default_instance()
		{
			return reinterpret_cast<const K2Message*>(
				&_K2Message_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			9;

		friend void swap(K2Message& a, K2Message& b)
		{
			a.Swap(&b);
		}

		void Swap(K2Message* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2Message* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2Message>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2Message& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2Message& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2Message* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2Message";
		}

	protected:
		explicit K2Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                   bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kTrackerBaseVectorFieldNumber = 4,
			kTrackerStatusesVectorFieldNumber = 5,
			kMessageStringFieldNumber = 9,
			kMessageTimestampFieldNumber = 2,
			kMessageManualTimestampFieldNumber = 3,
			kMessageTypeFieldNumber = 1,
			kTrackerFieldNumber = 6,
			kStateFieldNumber = 7,
			kWantReplyFieldNumber = 8,
		};

		// repeated .ktvr.K2TrackerBase trackerBaseVector = 4;
		int trackerbasevector_size() const;

	private:
		int _internal_trackerbasevector_size() const;

	public:
		void clear_trackerbasevector();
		K2TrackerBase* mutable_trackerbasevector(int index);
		::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2TrackerBase>*
		mutable_trackerbasevector();

	private:
		const K2TrackerBase& _internal_trackerbasevector(int index) const;
		K2TrackerBase* _internal_add_trackerbasevector();

	public:
		const K2TrackerBase& trackerbasevector(int index) const;
		K2TrackerBase* add_trackerbasevector();
		const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2TrackerBase>&
		trackerbasevector() const;

		// repeated .ktvr.K2StatusPair trackerStatusesVector = 5;
		int trackerstatusesvector_size() const;

	private:
		int _internal_trackerstatusesvector_size() const;

	public:
		void clear_trackerstatusesvector();
		K2StatusPair* mutable_trackerstatusesvector(int index);
		::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2StatusPair>*
		mutable_trackerstatusesvector();

	private:
		const K2StatusPair& _internal_trackerstatusesvector(int index) const;
		K2StatusPair* _internal_add_trackerstatusesvector();

	public:
		const K2StatusPair& trackerstatusesvector(int index) const;
		K2StatusPair* add_trackerstatusesvector();
		const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2StatusPair>&
		trackerstatusesvector() const;

		// string message_string = 9;
		void clear_message_string();
		const std::string& message_string() const;
		template <typename ArgT0 = const std::string&, typename... ArgT>
		void set_message_string(ArgT0&& arg0, ArgT... args);
		std::string* mutable_message_string();
		PROTOBUF_NODISCARD std::string* release_message_string();
		void set_allocated_message_string(std::string* message_string);

	private:
		const std::string& _internal_message_string() const;
		inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_string(const std::string& value);
		std::string* _internal_mutable_message_string();

	public:
		// int64 messageTimestamp = 2;
		void clear_messagetimestamp();
		int64_t messagetimestamp() const;
		void set_messagetimestamp(int64_t value);

	private:
		int64_t _internal_messagetimestamp() const;
		void _internal_set_messagetimestamp(int64_t value);

	public:
		// int64 messageManualTimestamp = 3;
		void clear_messagemanualtimestamp();
		int64_t messagemanualtimestamp() const;
		void set_messagemanualtimestamp(int64_t value);

	private:
		int64_t _internal_messagemanualtimestamp() const;
		void _internal_set_messagemanualtimestamp(int64_t value);

	public:
		// .ktvr.K2MessageType messageType = 1;
		void clear_messagetype();
		K2MessageType messagetype() const;
		void set_messagetype(K2MessageType value);

	private:
		K2MessageType _internal_messagetype() const;
		void _internal_set_messagetype(K2MessageType value);

	public:
		// .ktvr.ITrackerType tracker = 6;
		void clear_tracker();
		ITrackerType tracker() const;
		void set_tracker(ITrackerType value);

	private:
		ITrackerType _internal_tracker() const;
		void _internal_set_tracker(ITrackerType value);

	public:
		// bool state = 7;
		void clear_state();
		bool state() const;
		void set_state(bool value);

	private:
		bool _internal_state() const;
		void _internal_set_state(bool value);

	public:
		// bool want_reply = 8;
		void clear_want_reply();
		bool want_reply() const;
		void set_want_reply(bool value);

	private:
		bool _internal_want_reply() const;
		void _internal_set_want_reply(bool value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2Message)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2TrackerBase> trackerbasevector_;
			::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2StatusPair> trackerstatusesvector_;
			::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_string_;
			int64_t messagetimestamp_;
			int64_t messagemanualtimestamp_;
			int messagetype_;
			int tracker_;
			bool state_;
			bool want_reply_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// -------------------------------------------------------------------

	class KTVR_API K2ResponseMessage final :
		public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ktvr.K2ResponseMessage) */
	{
	public:
		K2ResponseMessage() : K2ResponseMessage(nullptr)
		{
		}

		~K2ResponseMessage() override;
		explicit PROTOBUF_CONSTEXPR K2ResponseMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

		K2ResponseMessage(const K2ResponseMessage& from);

		K2ResponseMessage(K2ResponseMessage&& from) noexcept
			: K2ResponseMessage()
		{
			*this = std::move(from);
		}

		K2ResponseMessage& operator=(const K2ResponseMessage& from)
		{
			CopyFrom(from);
			return *this;
		}

		K2ResponseMessage& operator=(K2ResponseMessage&& from) noexcept
		{
			if (this == &from) return *this;
			if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
			)
			{
				InternalSwap(&from);
			}
			else
			{
				CopyFrom(from);
			}
			return *this;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor()
		{
			return GetDescriptor();
		}

		static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor()
		{
			return default_instance().GetMetadata().descriptor;
		}

		static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection()
		{
			return default_instance().GetMetadata().reflection;
		}

		static const K2ResponseMessage& default_instance()
		{
			return *internal_default_instance();
		}

		static const K2ResponseMessage* internal_default_instance()
		{
			return reinterpret_cast<const K2ResponseMessage*>(
				&_K2ResponseMessage_default_instance_);
		}

		static constexpr int kIndexInFileMessages =
			10;

		friend void swap(K2ResponseMessage& a, K2ResponseMessage& b)
		{
			a.Swap(&b);
		}

		void Swap(K2ResponseMessage* other)
		{
			if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
			if (GetOwningArena() == other->GetOwningArena())
			{
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
				InternalSwap(other);
			}
			else
			{
				::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
			}
		}

		void UnsafeArenaSwap(K2ResponseMessage* other)
		{
			if (other == this) return;
			GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
			InternalSwap(other);
		}

		// implements Message ----------------------------------------------

		K2ResponseMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const
		{
			return CreateMaybeMessage<K2ResponseMessage>(arena);
		}

		using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
		void CopyFrom(const K2ResponseMessage& from);
		using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;

		void MergeFrom(const K2ResponseMessage& from)
		{
			MergeImpl(*this, from);
		}

	private:
		static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg,
		                      const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);

	public:
		PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
		bool IsInitialized() const;

		size_t ByteSizeLong() const;
		const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx);
		uint8_t* _InternalSerialize(
			uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const;
		int GetCachedSize() const { return _impl_._cached_size_.Get(); }

	private:
		void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
		void SharedDtor();
		void SetCachedSize(int size) const;
		void InternalSwap(K2ResponseMessage* other);

	private:
		friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

		static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
		{
			return "ktvr.K2ResponseMessage";
		}

	protected:
		explicit K2ResponseMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
		                           bool is_message_owned = false);

	public:
		static const ClassData _class_data_;
		const ::PROTOBUF_NAMESPACE_ID::Message::ClassData* GetClassData() const;

		::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const;

		// nested types ----------------------------------------------------

		// accessors -------------------------------------------------------

		enum : int
		{
			kMessageTimestampFieldNumber = 2,
			kMessageTypeFieldNumber = 1,
			kTrackerFieldNumber = 4,
			kMessageManualTimestampFieldNumber = 3,
			kResultFieldNumber = 5,
			kSuccessFieldNumber = 6,
		};

		// int64 messageTimestamp = 2;
		void clear_messagetimestamp();
		int64_t messagetimestamp() const;
		void set_messagetimestamp(int64_t value);

	private:
		int64_t _internal_messagetimestamp() const;
		void _internal_set_messagetimestamp(int64_t value);

	public:
		// .ktvr.K2ResponseMessageType messageType = 1;
		void clear_messagetype();
		K2ResponseMessageType messagetype() const;
		void set_messagetype(K2ResponseMessageType value);

	private:
		K2ResponseMessageType _internal_messagetype() const;
		void _internal_set_messagetype(K2ResponseMessageType value);

	public:
		// .ktvr.ITrackerType tracker = 4;
		void clear_tracker();
		ITrackerType tracker() const;
		void set_tracker(ITrackerType value);

	private:
		ITrackerType _internal_tracker() const;
		void _internal_set_tracker(ITrackerType value);

	public:
		// int64 messageManualTimestamp = 3;
		void clear_messagemanualtimestamp();
		int64_t messagemanualtimestamp() const;
		void set_messagemanualtimestamp(int64_t value);

	private:
		int64_t _internal_messagemanualtimestamp() const;
		void _internal_set_messagemanualtimestamp(int64_t value);

	public:
		// .ktvr.K2ResponseMessageCode result = 5;
		void clear_result();
		K2ResponseMessageCode result() const;
		void set_result(K2ResponseMessageCode value);

	private:
		K2ResponseMessageCode _internal_result() const;
		void _internal_set_result(K2ResponseMessageCode value);

	public:
		// bool success = 6;
		void clear_success();
		bool success() const;
		void set_success(bool value);

	private:
		bool _internal_success() const;
		void _internal_set_success(bool value);

	public:
		// @@protoc_insertion_point(class_scope:ktvr.K2ResponseMessage)
	private:
		class _Internal;

		template <typename T>
		friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
		using InternalArenaConstructable_ = void;
		using DestructorSkippable_ = void;

		struct Impl_
		{
			int64_t messagetimestamp_;
			int messagetype_;
			int tracker_;
			int64_t messagemanualtimestamp_;
			int result_;
			bool success_;
			mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
		};

		union
		{
			Impl_ _impl_;
		};

		friend struct TableStruct_Amethyst_5fAPI_2eproto;
	};

	// ===================================================================


	// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
	// ServiceRequest

	// .ktvr.Service_SetTrackerStateRequest trackerStateTuple = 1;
	inline bool ServiceRequest::_internal_has_trackerstatetuple() const
	{
		return value_oneof_case() == kTrackerStateTuple;
	}

	inline bool ServiceRequest::has_trackerstatetuple() const
	{
		return _internal_has_trackerstatetuple();
	}

	inline void ServiceRequest::set_has_trackerstatetuple()
	{
		_impl_._oneof_case_[0] = kTrackerStateTuple;
	}

	inline void ServiceRequest::clear_trackerstatetuple()
	{
		if (_internal_has_trackerstatetuple())
		{
			if (GetArenaForAllocation() == nullptr)
			{
				delete _impl_.value_oneof_.trackerstatetuple_;
			}
			clear_has_value_oneof();
		}
	}

	inline Service_SetTrackerStateRequest* ServiceRequest::release_trackerstatetuple()
	{
		// @@protoc_insertion_point(field_release:ktvr.ServiceRequest.trackerStateTuple)
		if (_internal_has_trackerstatetuple())
		{
			clear_has_value_oneof();
			Service_SetTrackerStateRequest* temp = _impl_.value_oneof_.trackerstatetuple_;
			if (GetArenaForAllocation() != nullptr)
			{
				temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
			}
			_impl_.value_oneof_.trackerstatetuple_ = nullptr;
			return temp;
		}
		return nullptr;
	}

	inline const Service_SetTrackerStateRequest& ServiceRequest::_internal_trackerstatetuple() const
	{
		return _internal_has_trackerstatetuple()
			       ? *_impl_.value_oneof_.trackerstatetuple_
			       : reinterpret_cast<Service_SetTrackerStateRequest&>(
				       _Service_SetTrackerStateRequest_default_instance_);
	}

	inline const Service_SetTrackerStateRequest& ServiceRequest::trackerstatetuple() const
	{
		// @@protoc_insertion_point(field_get:ktvr.ServiceRequest.trackerStateTuple)
		return _internal_trackerstatetuple();
	}

	inline Service_SetTrackerStateRequest* ServiceRequest::unsafe_arena_release_trackerstatetuple()
	{
		// @@protoc_insertion_point(field_unsafe_arena_release:ktvr.ServiceRequest.trackerStateTuple)
		if (_internal_has_trackerstatetuple())
		{
			clear_has_value_oneof();
			Service_SetTrackerStateRequest* temp = _impl_.value_oneof_.trackerstatetuple_;
			_impl_.value_oneof_.trackerstatetuple_ = nullptr;
			return temp;
		}
		return nullptr;
	}

	inline void ServiceRequest::unsafe_arena_set_allocated_trackerstatetuple(
		Service_SetTrackerStateRequest* trackerstatetuple)
	{
		clear_value_oneof();
		if (trackerstatetuple)
		{
			set_has_trackerstatetuple();
			_impl_.value_oneof_.trackerstatetuple_ = trackerstatetuple;
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.ServiceRequest.trackerStateTuple)
	}

	inline Service_SetTrackerStateRequest* ServiceRequest::_internal_mutable_trackerstatetuple()
	{
		if (!_internal_has_trackerstatetuple())
		{
			clear_value_oneof();
			set_has_trackerstatetuple();
			_impl_.value_oneof_.trackerstatetuple_ = CreateMaybeMessage<Service_SetTrackerStateRequest>(
				GetArenaForAllocation());
		}
		return _impl_.value_oneof_.trackerstatetuple_;
	}

	inline Service_SetTrackerStateRequest* ServiceRequest::mutable_trackerstatetuple()
	{
		Service_SetTrackerStateRequest* _msg = _internal_mutable_trackerstatetuple();
		// @@protoc_insertion_point(field_mutable:ktvr.ServiceRequest.trackerStateTuple)
		return _msg;
	}

	// .ktvr.K2TrackerBase trackerBase = 2;
	inline bool ServiceRequest::_internal_has_trackerbase() const
	{
		return value_oneof_case() == kTrackerBase;
	}

	inline bool ServiceRequest::has_trackerbase() const
	{
		return _internal_has_trackerbase();
	}

	inline void ServiceRequest::set_has_trackerbase()
	{
		_impl_._oneof_case_[0] = kTrackerBase;
	}

	inline void ServiceRequest::clear_trackerbase()
	{
		if (_internal_has_trackerbase())
		{
			if (GetArenaForAllocation() == nullptr)
			{
				delete _impl_.value_oneof_.trackerbase_;
			}
			clear_has_value_oneof();
		}
	}

	inline K2TrackerBase* ServiceRequest::release_trackerbase()
	{
		// @@protoc_insertion_point(field_release:ktvr.ServiceRequest.trackerBase)
		if (_internal_has_trackerbase())
		{
			clear_has_value_oneof();
			K2TrackerBase* temp = _impl_.value_oneof_.trackerbase_;
			if (GetArenaForAllocation() != nullptr)
			{
				temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
			}
			_impl_.value_oneof_.trackerbase_ = nullptr;
			return temp;
		}
		return nullptr;
	}

	inline const K2TrackerBase& ServiceRequest::_internal_trackerbase() const
	{
		return _internal_has_trackerbase()
			       ? *_impl_.value_oneof_.trackerbase_
			       : reinterpret_cast<K2TrackerBase&>(_K2TrackerBase_default_instance_);
	}

	inline const K2TrackerBase& ServiceRequest::trackerbase() const
	{
		// @@protoc_insertion_point(field_get:ktvr.ServiceRequest.trackerBase)
		return _internal_trackerbase();
	}

	inline K2TrackerBase* ServiceRequest::unsafe_arena_release_trackerbase()
	{
		// @@protoc_insertion_point(field_unsafe_arena_release:ktvr.ServiceRequest.trackerBase)
		if (_internal_has_trackerbase())
		{
			clear_has_value_oneof();
			K2TrackerBase* temp = _impl_.value_oneof_.trackerbase_;
			_impl_.value_oneof_.trackerbase_ = nullptr;
			return temp;
		}
		return nullptr;
	}

	inline void ServiceRequest::unsafe_arena_set_allocated_trackerbase(K2TrackerBase* trackerbase)
	{
		clear_value_oneof();
		if (trackerbase)
		{
			set_has_trackerbase();
			_impl_.value_oneof_.trackerbase_ = trackerbase;
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.ServiceRequest.trackerBase)
	}

	inline K2TrackerBase* ServiceRequest::_internal_mutable_trackerbase()
	{
		if (!_internal_has_trackerbase())
		{
			clear_value_oneof();
			set_has_trackerbase();
			_impl_.value_oneof_.trackerbase_ = CreateMaybeMessage<K2TrackerBase>(GetArenaForAllocation());
		}
		return _impl_.value_oneof_.trackerbase_;
	}

	inline K2TrackerBase* ServiceRequest::mutable_trackerbase()
	{
		K2TrackerBase* _msg = _internal_mutable_trackerbase();
		// @@protoc_insertion_point(field_mutable:ktvr.ServiceRequest.trackerBase)
		return _msg;
	}

	// string message = 3;
	inline bool ServiceRequest::_internal_has_message() const
	{
		return value_oneof_case() == kMessage;
	}

	inline bool ServiceRequest::has_message() const
	{
		return _internal_has_message();
	}

	inline void ServiceRequest::set_has_message()
	{
		_impl_._oneof_case_[0] = kMessage;
	}

	inline void ServiceRequest::clear_message()
	{
		if (_internal_has_message())
		{
			_impl_.value_oneof_.message_.Destroy();
			clear_has_value_oneof();
		}
	}

	inline const std::string& ServiceRequest::message() const
	{
		// @@protoc_insertion_point(field_get:ktvr.ServiceRequest.message)
		return _internal_message();
	}

	template <typename ArgT0, typename... ArgT>
	void ServiceRequest::set_message(ArgT0&& arg0, ArgT... args)
	{
		if (!_internal_has_message())
		{
			clear_value_oneof();
			set_has_message();
			_impl_.value_oneof_.message_.InitDefault();
		}
		_impl_.value_oneof_.message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
		// @@protoc_insertion_point(field_set:ktvr.ServiceRequest.message)
	}

	inline std::string* ServiceRequest::mutable_message()
	{
		std::string* _s = _internal_mutable_message();
		// @@protoc_insertion_point(field_mutable:ktvr.ServiceRequest.message)
		return _s;
	}

	inline const std::string& ServiceRequest::_internal_message() const
	{
		if (_internal_has_message())
		{
			return _impl_.value_oneof_.message_.Get();
		}
		return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
	}

	inline void ServiceRequest::_internal_set_message(const std::string& value)
	{
		if (!_internal_has_message())
		{
			clear_value_oneof();
			set_has_message();
			_impl_.value_oneof_.message_.InitDefault();
		}
		_impl_.value_oneof_.message_.Set(value, GetArenaForAllocation());
	}

	inline std::string* ServiceRequest::_internal_mutable_message()
	{
		if (!_internal_has_message())
		{
			clear_value_oneof();
			set_has_message();
			_impl_.value_oneof_.message_.InitDefault();
		}
		return _impl_.value_oneof_.message_.Mutable(GetArenaForAllocation());
	}

	inline std::string* ServiceRequest::release_message()
	{
		// @@protoc_insertion_point(field_release:ktvr.ServiceRequest.message)
		if (_internal_has_message())
		{
			clear_has_value_oneof();
			return _impl_.value_oneof_.message_.Release();
		}
		return nullptr;
	}

	inline void ServiceRequest::set_allocated_message(std::string* message)
	{
		if (has_value_oneof())
		{
			clear_value_oneof();
		}
		if (message != nullptr)
		{
			set_has_message();
			_impl_.value_oneof_.message_.InitAllocated(message, GetArenaForAllocation());
		}
		// @@protoc_insertion_point(field_set_allocated:ktvr.ServiceRequest.message)
	}

	inline bool ServiceRequest::has_value_oneof() const
	{
		return value_oneof_case() != VALUE_ONEOF_NOT_SET;
	}

	inline void ServiceRequest::clear_has_value_oneof()
	{
		_impl_._oneof_case_[0] = VALUE_ONEOF_NOT_SET;
	}

	inline ServiceRequest::ValueOneofCase ServiceRequest::value_oneof_case() const
	{
		return static_cast<ServiceRequest::ValueOneofCase>(_impl_._oneof_case_[0]);
	}

	// -------------------------------------------------------------------

	// Service_SetTrackerStateRequest

	// .ktvr.ITrackerType trackerType = 1;
	inline void Service_SetTrackerStateRequest::clear_trackertype()
	{
		_impl_.trackertype_ = 0;
	}

	inline ITrackerType Service_SetTrackerStateRequest::_internal_trackertype() const
	{
		return static_cast<ITrackerType>(_impl_.trackertype_);
	}

	inline ITrackerType Service_SetTrackerStateRequest::trackertype() const
	{
		// @@protoc_insertion_point(field_get:ktvr.Service_SetTrackerStateRequest.trackerType)
		return _internal_trackertype();
	}

	inline void Service_SetTrackerStateRequest::_internal_set_trackertype(ITrackerType value)
	{
		_impl_.trackertype_ = value;
	}

	inline void Service_SetTrackerStateRequest::set_trackertype(ITrackerType value)
	{
		_internal_set_trackertype(value);
		// @@protoc_insertion_point(field_set:ktvr.Service_SetTrackerStateRequest.trackerType)
	}

	// bool state = 2;
	inline void Service_SetTrackerStateRequest::clear_state()
	{
		_impl_.state_ = false;
	}

	inline bool Service_SetTrackerStateRequest::_internal_state() const
	{
		return _impl_.state_;
	}

	inline bool Service_SetTrackerStateRequest::state() const
	{
		// @@protoc_insertion_point(field_get:ktvr.Service_SetTrackerStateRequest.state)
		return _internal_state();
	}

	inline void Service_SetTrackerStateRequest::_internal_set_state(bool value)
	{
		_impl_.state_ = value;
	}

	inline void Service_SetTrackerStateRequest::set_state(bool value)
	{
		_internal_set_state(value);
		// @@protoc_insertion_point(field_set:ktvr.Service_SetTrackerStateRequest.state)
	}

	// -------------------------------------------------------------------

	// K2Quaternion

	// double w = 1;
	inline void K2Quaternion::clear_w()
	{
		_impl_.w_ = 0;
	}

	inline double K2Quaternion::_internal_w() const
	{
		return _impl_.w_;
	}

	inline double K2Quaternion::w() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Quaternion.w)
		return _internal_w();
	}

	inline void K2Quaternion::_internal_set_w(double value)
	{
		_impl_.w_ = value;
	}

	inline void K2Quaternion::set_w(double value)
	{
		_internal_set_w(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Quaternion.w)
	}

	// double x = 2;
	inline void K2Quaternion::clear_x()
	{
		_impl_.x_ = 0;
	}

	inline double K2Quaternion::_internal_x() const
	{
		return _impl_.x_;
	}

	inline double K2Quaternion::x() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Quaternion.x)
		return _internal_x();
	}

	inline void K2Quaternion::_internal_set_x(double value)
	{
		_impl_.x_ = value;
	}

	inline void K2Quaternion::set_x(double value)
	{
		_internal_set_x(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Quaternion.x)
	}

	// double y = 3;
	inline void K2Quaternion::clear_y()
	{
		_impl_.y_ = 0;
	}

	inline double K2Quaternion::_internal_y() const
	{
		return _impl_.y_;
	}

	inline double K2Quaternion::y() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Quaternion.y)
		return _internal_y();
	}

	inline void K2Quaternion::_internal_set_y(double value)
	{
		_impl_.y_ = value;
	}

	inline void K2Quaternion::set_y(double value)
	{
		_internal_set_y(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Quaternion.y)
	}

	// double z = 4;
	inline void K2Quaternion::clear_z()
	{
		_impl_.z_ = 0;
	}

	inline double K2Quaternion::_internal_z() const
	{
		return _impl_.z_;
	}

	inline double K2Quaternion::z() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Quaternion.z)
		return _internal_z();
	}

	inline void K2Quaternion::_internal_set_z(double value)
	{
		_impl_.z_ = value;
	}

	inline void K2Quaternion::set_z(double value)
	{
		_internal_set_z(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Quaternion.z)
	}

	// -------------------------------------------------------------------

	// K2Vector3

	// double x = 1;
	inline void K2Vector3::clear_x()
	{
		_impl_.x_ = 0;
	}

	inline double K2Vector3::_internal_x() const
	{
		return _impl_.x_;
	}

	inline double K2Vector3::x() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Vector3.x)
		return _internal_x();
	}

	inline void K2Vector3::_internal_set_x(double value)
	{
		_impl_.x_ = value;
	}

	inline void K2Vector3::set_x(double value)
	{
		_internal_set_x(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Vector3.x)
	}

	// double y = 2;
	inline void K2Vector3::clear_y()
	{
		_impl_.y_ = 0;
	}

	inline double K2Vector3::_internal_y() const
	{
		return _impl_.y_;
	}

	inline double K2Vector3::y() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Vector3.y)
		return _internal_y();
	}

	inline void K2Vector3::_internal_set_y(double value)
	{
		_impl_.y_ = value;
	}

	inline void K2Vector3::set_y(double value)
	{
		_internal_set_y(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Vector3.y)
	}

	// double z = 3;
	inline void K2Vector3::clear_z()
	{
		_impl_.z_ = 0;
	}

	inline double K2Vector3::_internal_z() const
	{
		return _impl_.z_;
	}

	inline double K2Vector3::z() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Vector3.z)
		return _internal_z();
	}

	inline void K2Vector3::_internal_set_z(double value)
	{
		_impl_.z_ = value;
	}

	inline void K2Vector3::set_z(double value)
	{
		_internal_set_z(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Vector3.z)
	}

	// -------------------------------------------------------------------

	// K2TrackerPhysics

	// .ktvr.K2Vector3 velocity = 1;
	inline bool K2TrackerPhysics::_internal_has_velocity() const
	{
		return this != internal_default_instance() && _impl_.velocity_ != nullptr;
	}

	inline bool K2TrackerPhysics::has_velocity() const
	{
		return _internal_has_velocity();
	}

	inline void K2TrackerPhysics::clear_velocity()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr)
		{
			delete _impl_.velocity_;
		}
		_impl_.velocity_ = nullptr;
	}

	inline const K2Vector3& K2TrackerPhysics::_internal_velocity() const
	{
		const K2Vector3* p = _impl_.velocity_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2Vector3&>(
				       _K2Vector3_default_instance_);
	}

	inline const K2Vector3& K2TrackerPhysics::velocity() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPhysics.velocity)
		return _internal_velocity();
	}

	inline void K2TrackerPhysics::unsafe_arena_set_allocated_velocity(
		K2Vector3* velocity)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
		}
		_impl_.velocity_ = velocity;
		if (velocity)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPhysics.velocity)
	}

	inline K2Vector3* K2TrackerPhysics::release_velocity()
	{
		K2Vector3* temp = _impl_.velocity_;
		_impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::unsafe_arena_release_velocity()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPhysics.velocity)

		K2Vector3* temp = _impl_.velocity_;
		_impl_.velocity_ = nullptr;
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::_internal_mutable_velocity()
	{
		if (_impl_.velocity_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2Vector3>(GetArenaForAllocation());
			_impl_.velocity_ = p;
		}
		return _impl_.velocity_;
	}

	inline K2Vector3* K2TrackerPhysics::mutable_velocity()
	{
		K2Vector3* _msg = _internal_mutable_velocity();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPhysics.velocity)
		return _msg;
	}

	inline void K2TrackerPhysics::set_allocated_velocity(K2Vector3* velocity)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.velocity_;
		}
		if (velocity)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
			if (message_arena != submessage_arena)
			{
				velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, velocity, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.velocity_ = velocity;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPhysics.velocity)
	}

	// .ktvr.K2Vector3 acceleration = 2;
	inline bool K2TrackerPhysics::_internal_has_acceleration() const
	{
		return this != internal_default_instance() && _impl_.acceleration_ != nullptr;
	}

	inline bool K2TrackerPhysics::has_acceleration() const
	{
		return _internal_has_acceleration();
	}

	inline void K2TrackerPhysics::clear_acceleration()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.acceleration_ != nullptr)
		{
			delete _impl_.acceleration_;
		}
		_impl_.acceleration_ = nullptr;
	}

	inline const K2Vector3& K2TrackerPhysics::_internal_acceleration() const
	{
		const K2Vector3* p = _impl_.acceleration_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2Vector3&>(
				       _K2Vector3_default_instance_);
	}

	inline const K2Vector3& K2TrackerPhysics::acceleration() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPhysics.acceleration)
		return _internal_acceleration();
	}

	inline void K2TrackerPhysics::unsafe_arena_set_allocated_acceleration(
		K2Vector3* acceleration)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
		}
		_impl_.acceleration_ = acceleration;
		if (acceleration)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPhysics.acceleration)
	}

	inline K2Vector3* K2TrackerPhysics::release_acceleration()
	{
		K2Vector3* temp = _impl_.acceleration_;
		_impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::unsafe_arena_release_acceleration()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPhysics.acceleration)

		K2Vector3* temp = _impl_.acceleration_;
		_impl_.acceleration_ = nullptr;
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::_internal_mutable_acceleration()
	{
		if (_impl_.acceleration_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2Vector3>(GetArenaForAllocation());
			_impl_.acceleration_ = p;
		}
		return _impl_.acceleration_;
	}

	inline K2Vector3* K2TrackerPhysics::mutable_acceleration()
	{
		K2Vector3* _msg = _internal_mutable_acceleration();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPhysics.acceleration)
		return _msg;
	}

	inline void K2TrackerPhysics::set_allocated_acceleration(K2Vector3* acceleration)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.acceleration_;
		}
		if (acceleration)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acceleration);
			if (message_arena != submessage_arena)
			{
				acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, acceleration, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.acceleration_ = acceleration;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPhysics.acceleration)
	}

	// .ktvr.K2Vector3 angularVelocity = 3;
	inline bool K2TrackerPhysics::_internal_has_angularvelocity() const
	{
		return this != internal_default_instance() && _impl_.angularvelocity_ != nullptr;
	}

	inline bool K2TrackerPhysics::has_angularvelocity() const
	{
		return _internal_has_angularvelocity();
	}

	inline void K2TrackerPhysics::clear_angularvelocity()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.angularvelocity_ != nullptr)
		{
			delete _impl_.angularvelocity_;
		}
		_impl_.angularvelocity_ = nullptr;
	}

	inline const K2Vector3& K2TrackerPhysics::_internal_angularvelocity() const
	{
		const K2Vector3* p = _impl_.angularvelocity_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2Vector3&>(
				       _K2Vector3_default_instance_);
	}

	inline const K2Vector3& K2TrackerPhysics::angularvelocity() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPhysics.angularVelocity)
		return _internal_angularvelocity();
	}

	inline void K2TrackerPhysics::unsafe_arena_set_allocated_angularvelocity(
		K2Vector3* angularvelocity)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angularvelocity_);
		}
		_impl_.angularvelocity_ = angularvelocity;
		if (angularvelocity)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPhysics.angularVelocity)
	}

	inline K2Vector3* K2TrackerPhysics::release_angularvelocity()
	{
		K2Vector3* temp = _impl_.angularvelocity_;
		_impl_.angularvelocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::unsafe_arena_release_angularvelocity()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPhysics.angularVelocity)

		K2Vector3* temp = _impl_.angularvelocity_;
		_impl_.angularvelocity_ = nullptr;
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::_internal_mutable_angularvelocity()
	{
		if (_impl_.angularvelocity_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2Vector3>(GetArenaForAllocation());
			_impl_.angularvelocity_ = p;
		}
		return _impl_.angularvelocity_;
	}

	inline K2Vector3* K2TrackerPhysics::mutable_angularvelocity()
	{
		K2Vector3* _msg = _internal_mutable_angularvelocity();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPhysics.angularVelocity)
		return _msg;
	}

	inline void K2TrackerPhysics::set_allocated_angularvelocity(K2Vector3* angularvelocity)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.angularvelocity_;
		}
		if (angularvelocity)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angularvelocity);
			if (message_arena != submessage_arena)
			{
				angularvelocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, angularvelocity, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.angularvelocity_ = angularvelocity;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPhysics.angularVelocity)
	}

	// .ktvr.K2Vector3 angularAcceleration = 4;
	inline bool K2TrackerPhysics::_internal_has_angularacceleration() const
	{
		return this != internal_default_instance() && _impl_.angularacceleration_ != nullptr;
	}

	inline bool K2TrackerPhysics::has_angularacceleration() const
	{
		return _internal_has_angularacceleration();
	}

	inline void K2TrackerPhysics::clear_angularacceleration()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.angularacceleration_ != nullptr)
		{
			delete _impl_.angularacceleration_;
		}
		_impl_.angularacceleration_ = nullptr;
	}

	inline const K2Vector3& K2TrackerPhysics::_internal_angularacceleration() const
	{
		const K2Vector3* p = _impl_.angularacceleration_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2Vector3&>(
				       _K2Vector3_default_instance_);
	}

	inline const K2Vector3& K2TrackerPhysics::angularacceleration() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPhysics.angularAcceleration)
		return _internal_angularacceleration();
	}

	inline void K2TrackerPhysics::unsafe_arena_set_allocated_angularacceleration(
		K2Vector3* angularacceleration)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.angularacceleration_);
		}
		_impl_.angularacceleration_ = angularacceleration;
		if (angularacceleration)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPhysics.angularAcceleration)
	}

	inline K2Vector3* K2TrackerPhysics::release_angularacceleration()
	{
		K2Vector3* temp = _impl_.angularacceleration_;
		_impl_.angularacceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::unsafe_arena_release_angularacceleration()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPhysics.angularAcceleration)

		K2Vector3* temp = _impl_.angularacceleration_;
		_impl_.angularacceleration_ = nullptr;
		return temp;
	}

	inline K2Vector3* K2TrackerPhysics::_internal_mutable_angularacceleration()
	{
		if (_impl_.angularacceleration_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2Vector3>(GetArenaForAllocation());
			_impl_.angularacceleration_ = p;
		}
		return _impl_.angularacceleration_;
	}

	inline K2Vector3* K2TrackerPhysics::mutable_angularacceleration()
	{
		K2Vector3* _msg = _internal_mutable_angularacceleration();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPhysics.angularAcceleration)
		return _msg;
	}

	inline void K2TrackerPhysics::set_allocated_angularacceleration(K2Vector3* angularacceleration)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.angularacceleration_;
		}
		if (angularacceleration)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(angularacceleration);
			if (message_arena != submessage_arena)
			{
				angularacceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, angularacceleration, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.angularacceleration_ = angularacceleration;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPhysics.angularAcceleration)
	}

	// -------------------------------------------------------------------

	// K2TrackerPose

	// .ktvr.K2Quaternion orientation = 1;
	inline bool K2TrackerPose::_internal_has_orientation() const
	{
		return this != internal_default_instance() && _impl_.orientation_ != nullptr;
	}

	inline bool K2TrackerPose::has_orientation() const
	{
		return _internal_has_orientation();
	}

	inline void K2TrackerPose::clear_orientation()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.orientation_ != nullptr)
		{
			delete _impl_.orientation_;
		}
		_impl_.orientation_ = nullptr;
	}

	inline const K2Quaternion& K2TrackerPose::_internal_orientation() const
	{
		const K2Quaternion* p = _impl_.orientation_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2Quaternion&>(
				       _K2Quaternion_default_instance_);
	}

	inline const K2Quaternion& K2TrackerPose::orientation() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPose.orientation)
		return _internal_orientation();
	}

	inline void K2TrackerPose::unsafe_arena_set_allocated_orientation(
		K2Quaternion* orientation)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.orientation_);
		}
		_impl_.orientation_ = orientation;
		if (orientation)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPose.orientation)
	}

	inline K2Quaternion* K2TrackerPose::release_orientation()
	{
		K2Quaternion* temp = _impl_.orientation_;
		_impl_.orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2Quaternion* K2TrackerPose::unsafe_arena_release_orientation()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPose.orientation)

		K2Quaternion* temp = _impl_.orientation_;
		_impl_.orientation_ = nullptr;
		return temp;
	}

	inline K2Quaternion* K2TrackerPose::_internal_mutable_orientation()
	{
		if (_impl_.orientation_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2Quaternion>(GetArenaForAllocation());
			_impl_.orientation_ = p;
		}
		return _impl_.orientation_;
	}

	inline K2Quaternion* K2TrackerPose::mutable_orientation()
	{
		K2Quaternion* _msg = _internal_mutable_orientation();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPose.orientation)
		return _msg;
	}

	inline void K2TrackerPose::set_allocated_orientation(K2Quaternion* orientation)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.orientation_;
		}
		if (orientation)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(orientation);
			if (message_arena != submessage_arena)
			{
				orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, orientation, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.orientation_ = orientation;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPose.orientation)
	}

	// .ktvr.K2Vector3 position = 2;
	inline bool K2TrackerPose::_internal_has_position() const
	{
		return this != internal_default_instance() && _impl_.position_ != nullptr;
	}

	inline bool K2TrackerPose::has_position() const
	{
		return _internal_has_position();
	}

	inline void K2TrackerPose::clear_position()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr)
		{
			delete _impl_.position_;
		}
		_impl_.position_ = nullptr;
	}

	inline const K2Vector3& K2TrackerPose::_internal_position() const
	{
		const K2Vector3* p = _impl_.position_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2Vector3&>(
				       _K2Vector3_default_instance_);
	}

	inline const K2Vector3& K2TrackerPose::position() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPose.position)
		return _internal_position();
	}

	inline void K2TrackerPose::unsafe_arena_set_allocated_position(
		K2Vector3* position)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
		}
		_impl_.position_ = position;
		if (position)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPose.position)
	}

	inline K2Vector3* K2TrackerPose::release_position()
	{
		K2Vector3* temp = _impl_.position_;
		_impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2Vector3* K2TrackerPose::unsafe_arena_release_position()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPose.position)

		K2Vector3* temp = _impl_.position_;
		_impl_.position_ = nullptr;
		return temp;
	}

	inline K2Vector3* K2TrackerPose::_internal_mutable_position()
	{
		if (_impl_.position_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2Vector3>(GetArenaForAllocation());
			_impl_.position_ = p;
		}
		return _impl_.position_;
	}

	inline K2Vector3* K2TrackerPose::mutable_position()
	{
		K2Vector3* _msg = _internal_mutable_position();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPose.position)
		return _msg;
	}

	inline void K2TrackerPose::set_allocated_position(K2Vector3* position)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.position_;
		}
		if (position)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
			if (message_arena != submessage_arena)
			{
				position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, position, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.position_ = position;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPose.position)
	}

	// optional .ktvr.K2TrackerPhysics physics = 3;
	inline bool K2TrackerPose::_internal_has_physics() const
	{
		bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
		PROTOBUF_ASSUME(!value || _impl_.physics_ != nullptr);
		return value;
	}

	inline bool K2TrackerPose::has_physics() const
	{
		return _internal_has_physics();
	}

	inline void K2TrackerPose::clear_physics()
	{
		if (_impl_.physics_ != nullptr) _impl_.physics_->Clear();
		_impl_._has_bits_[0] &= ~0x00000001u;
	}

	inline const K2TrackerPhysics& K2TrackerPose::_internal_physics() const
	{
		const K2TrackerPhysics* p = _impl_.physics_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2TrackerPhysics&>(
				       _K2TrackerPhysics_default_instance_);
	}

	inline const K2TrackerPhysics& K2TrackerPose::physics() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerPose.physics)
		return _internal_physics();
	}

	inline void K2TrackerPose::unsafe_arena_set_allocated_physics(
		K2TrackerPhysics* physics)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.physics_);
		}
		_impl_.physics_ = physics;
		if (physics)
		{
			_impl_._has_bits_[0] |= 0x00000001u;
		}
		else
		{
			_impl_._has_bits_[0] &= ~0x00000001u;
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerPose.physics)
	}

	inline K2TrackerPhysics* K2TrackerPose::release_physics()
	{
		_impl_._has_bits_[0] &= ~0x00000001u;
		K2TrackerPhysics* temp = _impl_.physics_;
		_impl_.physics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2TrackerPhysics* K2TrackerPose::unsafe_arena_release_physics()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerPose.physics)
		_impl_._has_bits_[0] &= ~0x00000001u;
		K2TrackerPhysics* temp = _impl_.physics_;
		_impl_.physics_ = nullptr;
		return temp;
	}

	inline K2TrackerPhysics* K2TrackerPose::_internal_mutable_physics()
	{
		_impl_._has_bits_[0] |= 0x00000001u;
		if (_impl_.physics_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2TrackerPhysics>(GetArenaForAllocation());
			_impl_.physics_ = p;
		}
		return _impl_.physics_;
	}

	inline K2TrackerPhysics* K2TrackerPose::mutable_physics()
	{
		K2TrackerPhysics* _msg = _internal_mutable_physics();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerPose.physics)
		return _msg;
	}

	inline void K2TrackerPose::set_allocated_physics(K2TrackerPhysics* physics)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.physics_;
		}
		if (physics)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(physics);
			if (message_arena != submessage_arena)
			{
				physics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, physics, submessage_arena);
			}
			_impl_._has_bits_[0] |= 0x00000001u;
		}
		else
		{
			_impl_._has_bits_[0] &= ~0x00000001u;
		}
		_impl_.physics_ = physics;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerPose.physics)
	}

	// -------------------------------------------------------------------

	// K2StatusPair

	// .ktvr.ITrackerType tracker = 1;
	inline void K2StatusPair::clear_tracker()
	{
		_impl_.tracker_ = 0;
	}

	inline ITrackerType K2StatusPair::_internal_tracker() const
	{
		return static_cast<ITrackerType>(_impl_.tracker_);
	}

	inline ITrackerType K2StatusPair::tracker() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2StatusPair.tracker)
		return _internal_tracker();
	}

	inline void K2StatusPair::_internal_set_tracker(ITrackerType value)
	{
		_impl_.tracker_ = value;
	}

	inline void K2StatusPair::set_tracker(ITrackerType value)
	{
		_internal_set_tracker(value);
		// @@protoc_insertion_point(field_set:ktvr.K2StatusPair.tracker)
	}

	// bool status = 2;
	inline void K2StatusPair::clear_status()
	{
		_impl_.status_ = false;
	}

	inline bool K2StatusPair::_internal_status() const
	{
		return _impl_.status_;
	}

	inline bool K2StatusPair::status() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2StatusPair.status)
		return _internal_status();
	}

	inline void K2StatusPair::_internal_set_status(bool value)
	{
		_impl_.status_ = value;
	}

	inline void K2StatusPair::set_status(bool value)
	{
		_internal_set_status(value);
		// @@protoc_insertion_point(field_set:ktvr.K2StatusPair.status)
	}

	// -------------------------------------------------------------------

	// K2TrackerData

	// string serial = 1;
	inline void K2TrackerData::clear_serial()
	{
		_impl_.serial_.ClearToEmpty();
	}

	inline const std::string& K2TrackerData::serial() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerData.serial)
		return _internal_serial();
	}

	template <typename ArgT0, typename... ArgT>
	PROTOBUF_ALWAYS_INLINE
	void K2TrackerData::set_serial(ArgT0&& arg0, ArgT... args)
	{
		_impl_.serial_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
		// @@protoc_insertion_point(field_set:ktvr.K2TrackerData.serial)
	}

	inline std::string* K2TrackerData::mutable_serial()
	{
		std::string* _s = _internal_mutable_serial();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerData.serial)
		return _s;
	}

	inline const std::string& K2TrackerData::_internal_serial() const
	{
		return _impl_.serial_.Get();
	}

	inline void K2TrackerData::_internal_set_serial(const std::string& value)
	{
		_impl_.serial_.Set(value, GetArenaForAllocation());
	}

	inline std::string* K2TrackerData::_internal_mutable_serial()
	{
		return _impl_.serial_.Mutable(GetArenaForAllocation());
	}

	inline std::string* K2TrackerData::release_serial()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerData.serial)
		return _impl_.serial_.Release();
	}

	inline void K2TrackerData::set_allocated_serial(std::string* serial)
	{
		if (serial != nullptr)
		{
		}
		else
		{
		}
		_impl_.serial_.SetAllocated(serial, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serial_.IsDefault()) {
    _impl_.serial_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerData.serial)
	}

	// .ktvr.ITrackerType role = 2;
	inline void K2TrackerData::clear_role()
	{
		_impl_.role_ = 0;
	}

	inline ITrackerType K2TrackerData::_internal_role() const
	{
		return static_cast<ITrackerType>(_impl_.role_);
	}

	inline ITrackerType K2TrackerData::role() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerData.role)
		return _internal_role();
	}

	inline void K2TrackerData::_internal_set_role(ITrackerType value)
	{
		_impl_.role_ = value;
	}

	inline void K2TrackerData::set_role(ITrackerType value)
	{
		_internal_set_role(value);
		// @@protoc_insertion_point(field_set:ktvr.K2TrackerData.role)
	}

	// bool isActive = 3;
	inline void K2TrackerData::clear_isactive()
	{
		_impl_.isactive_ = false;
	}

	inline bool K2TrackerData::_internal_isactive() const
	{
		return _impl_.isactive_;
	}

	inline bool K2TrackerData::isactive() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerData.isActive)
		return _internal_isactive();
	}

	inline void K2TrackerData::_internal_set_isactive(bool value)
	{
		_impl_.isactive_ = value;
	}

	inline void K2TrackerData::set_isactive(bool value)
	{
		_internal_set_isactive(value);
		// @@protoc_insertion_point(field_set:ktvr.K2TrackerData.isActive)
	}

	// -------------------------------------------------------------------

	// K2TrackerBase

	// .ktvr.K2TrackerPose pose = 1;
	inline bool K2TrackerBase::_internal_has_pose() const
	{
		return this != internal_default_instance() && _impl_.pose_ != nullptr;
	}

	inline bool K2TrackerBase::has_pose() const
	{
		return _internal_has_pose();
	}

	inline void K2TrackerBase::clear_pose()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr)
		{
			delete _impl_.pose_;
		}
		_impl_.pose_ = nullptr;
	}

	inline const K2TrackerPose& K2TrackerBase::_internal_pose() const
	{
		const K2TrackerPose* p = _impl_.pose_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2TrackerPose&>(
				       _K2TrackerPose_default_instance_);
	}

	inline const K2TrackerPose& K2TrackerBase::pose() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerBase.pose)
		return _internal_pose();
	}

	inline void K2TrackerBase::unsafe_arena_set_allocated_pose(
		K2TrackerPose* pose)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
		}
		_impl_.pose_ = pose;
		if (pose)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerBase.pose)
	}

	inline K2TrackerPose* K2TrackerBase::release_pose()
	{
		K2TrackerPose* temp = _impl_.pose_;
		_impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2TrackerPose* K2TrackerBase::unsafe_arena_release_pose()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerBase.pose)

		K2TrackerPose* temp = _impl_.pose_;
		_impl_.pose_ = nullptr;
		return temp;
	}

	inline K2TrackerPose* K2TrackerBase::_internal_mutable_pose()
	{
		if (_impl_.pose_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2TrackerPose>(GetArenaForAllocation());
			_impl_.pose_ = p;
		}
		return _impl_.pose_;
	}

	inline K2TrackerPose* K2TrackerBase::mutable_pose()
	{
		K2TrackerPose* _msg = _internal_mutable_pose();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerBase.pose)
		return _msg;
	}

	inline void K2TrackerBase::set_allocated_pose(K2TrackerPose* pose)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.pose_;
		}
		if (pose)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pose);
			if (message_arena != submessage_arena)
			{
				pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, pose, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.pose_ = pose;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerBase.pose)
	}

	// .ktvr.K2TrackerData data = 2;
	inline bool K2TrackerBase::_internal_has_data() const
	{
		return this != internal_default_instance() && _impl_.data_ != nullptr;
	}

	inline bool K2TrackerBase::has_data() const
	{
		return _internal_has_data();
	}

	inline void K2TrackerBase::clear_data()
	{
		if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr)
		{
			delete _impl_.data_;
		}
		_impl_.data_ = nullptr;
	}

	inline const K2TrackerData& K2TrackerBase::_internal_data() const
	{
		const K2TrackerData* p = _impl_.data_;
		return p != nullptr
			       ? *p
			       : reinterpret_cast<const K2TrackerData&>(
				       _K2TrackerData_default_instance_);
	}

	inline const K2TrackerData& K2TrackerBase::data() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerBase.data)
		return _internal_data();
	}

	inline void K2TrackerBase::unsafe_arena_set_allocated_data(
		K2TrackerData* data)
	{
		if (GetArenaForAllocation() == nullptr)
		{
			delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
		}
		_impl_.data_ = data;
		if (data)
		{
		}
		else
		{
		}
		// @@protoc_insertion_point(field_unsafe_arena_set_allocated:ktvr.K2TrackerBase.data)
	}

	inline K2TrackerData* K2TrackerBase::release_data()
	{
		K2TrackerData* temp = _impl_.data_;
		_impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
		if (GetArenaForAllocation() != nullptr)
		{
			temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
		}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
		return temp;
	}

	inline K2TrackerData* K2TrackerBase::unsafe_arena_release_data()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2TrackerBase.data)

		K2TrackerData* temp = _impl_.data_;
		_impl_.data_ = nullptr;
		return temp;
	}

	inline K2TrackerData* K2TrackerBase::_internal_mutable_data()
	{
		if (_impl_.data_ == nullptr)
		{
			auto* p = CreateMaybeMessage<K2TrackerData>(GetArenaForAllocation());
			_impl_.data_ = p;
		}
		return _impl_.data_;
	}

	inline K2TrackerData* K2TrackerBase::mutable_data()
	{
		K2TrackerData* _msg = _internal_mutable_data();
		// @@protoc_insertion_point(field_mutable:ktvr.K2TrackerBase.data)
		return _msg;
	}

	inline void K2TrackerBase::set_allocated_data(K2TrackerData* data)
	{
		::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
		if (message_arena == nullptr)
		{
			delete _impl_.data_;
		}
		if (data)
		{
			::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
				::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
			if (message_arena != submessage_arena)
			{
				data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
					message_arena, data, submessage_arena);
			}
		}
		else
		{
		}
		_impl_.data_ = data;
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2TrackerBase.data)
	}

	// .ktvr.ITrackerType tracker = 3;
	inline void K2TrackerBase::clear_tracker()
	{
		_impl_.tracker_ = 0;
	}

	inline ITrackerType K2TrackerBase::_internal_tracker() const
	{
		return static_cast<ITrackerType>(_impl_.tracker_);
	}

	inline ITrackerType K2TrackerBase::tracker() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2TrackerBase.tracker)
		return _internal_tracker();
	}

	inline void K2TrackerBase::_internal_set_tracker(ITrackerType value)
	{
		_impl_.tracker_ = value;
	}

	inline void K2TrackerBase::set_tracker(ITrackerType value)
	{
		_internal_set_tracker(value);
		// @@protoc_insertion_point(field_set:ktvr.K2TrackerBase.tracker)
	}

	// -------------------------------------------------------------------

	// K2Message

	// .ktvr.K2MessageType messageType = 1;
	inline void K2Message::clear_messagetype()
	{
		_impl_.messagetype_ = 0;
	}

	inline K2MessageType K2Message::_internal_messagetype() const
	{
		return static_cast<K2MessageType>(_impl_.messagetype_);
	}

	inline K2MessageType K2Message::messagetype() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.messageType)
		return _internal_messagetype();
	}

	inline void K2Message::_internal_set_messagetype(K2MessageType value)
	{
		_impl_.messagetype_ = value;
	}

	inline void K2Message::set_messagetype(K2MessageType value)
	{
		_internal_set_messagetype(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Message.messageType)
	}

	// int64 messageTimestamp = 2;
	inline void K2Message::clear_messagetimestamp()
	{
		_impl_.messagetimestamp_ = int64_t{0};
	}

	inline int64_t K2Message::_internal_messagetimestamp() const
	{
		return _impl_.messagetimestamp_;
	}

	inline int64_t K2Message::messagetimestamp() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.messageTimestamp)
		return _internal_messagetimestamp();
	}

	inline void K2Message::_internal_set_messagetimestamp(int64_t value)
	{
		_impl_.messagetimestamp_ = value;
	}

	inline void K2Message::set_messagetimestamp(int64_t value)
	{
		_internal_set_messagetimestamp(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Message.messageTimestamp)
	}

	// int64 messageManualTimestamp = 3;
	inline void K2Message::clear_messagemanualtimestamp()
	{
		_impl_.messagemanualtimestamp_ = int64_t{0};
	}

	inline int64_t K2Message::_internal_messagemanualtimestamp() const
	{
		return _impl_.messagemanualtimestamp_;
	}

	inline int64_t K2Message::messagemanualtimestamp() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.messageManualTimestamp)
		return _internal_messagemanualtimestamp();
	}

	inline void K2Message::_internal_set_messagemanualtimestamp(int64_t value)
	{
		_impl_.messagemanualtimestamp_ = value;
	}

	inline void K2Message::set_messagemanualtimestamp(int64_t value)
	{
		_internal_set_messagemanualtimestamp(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Message.messageManualTimestamp)
	}

	// repeated .ktvr.K2TrackerBase trackerBaseVector = 4;
	inline int K2Message::_internal_trackerbasevector_size() const
	{
		return _impl_.trackerbasevector_.size();
	}

	inline int K2Message::trackerbasevector_size() const
	{
		return _internal_trackerbasevector_size();
	}

	inline void K2Message::clear_trackerbasevector()
	{
		_impl_.trackerbasevector_.Clear();
	}

	inline K2TrackerBase* K2Message::mutable_trackerbasevector(int index)
	{
		// @@protoc_insertion_point(field_mutable:ktvr.K2Message.trackerBaseVector)
		return _impl_.trackerbasevector_.Mutable(index);
	}

	inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2TrackerBase>*
	K2Message::mutable_trackerbasevector()
	{
		// @@protoc_insertion_point(field_mutable_list:ktvr.K2Message.trackerBaseVector)
		return &_impl_.trackerbasevector_;
	}

	inline const K2TrackerBase& K2Message::_internal_trackerbasevector(int index) const
	{
		return _impl_.trackerbasevector_.Get(index);
	}

	inline const K2TrackerBase& K2Message::trackerbasevector(int index) const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.trackerBaseVector)
		return _internal_trackerbasevector(index);
	}

	inline K2TrackerBase* K2Message::_internal_add_trackerbasevector()
	{
		return _impl_.trackerbasevector_.Add();
	}

	inline K2TrackerBase* K2Message::add_trackerbasevector()
	{
		K2TrackerBase* _add = _internal_add_trackerbasevector();
		// @@protoc_insertion_point(field_add:ktvr.K2Message.trackerBaseVector)
		return _add;
	}

	inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2TrackerBase>&
	K2Message::trackerbasevector() const
	{
		// @@protoc_insertion_point(field_list:ktvr.K2Message.trackerBaseVector)
		return _impl_.trackerbasevector_;
	}

	// repeated .ktvr.K2StatusPair trackerStatusesVector = 5;
	inline int K2Message::_internal_trackerstatusesvector_size() const
	{
		return _impl_.trackerstatusesvector_.size();
	}

	inline int K2Message::trackerstatusesvector_size() const
	{
		return _internal_trackerstatusesvector_size();
	}

	inline void K2Message::clear_trackerstatusesvector()
	{
		_impl_.trackerstatusesvector_.Clear();
	}

	inline K2StatusPair* K2Message::mutable_trackerstatusesvector(int index)
	{
		// @@protoc_insertion_point(field_mutable:ktvr.K2Message.trackerStatusesVector)
		return _impl_.trackerstatusesvector_.Mutable(index);
	}

	inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2StatusPair>*
	K2Message::mutable_trackerstatusesvector()
	{
		// @@protoc_insertion_point(field_mutable_list:ktvr.K2Message.trackerStatusesVector)
		return &_impl_.trackerstatusesvector_;
	}

	inline const K2StatusPair& K2Message::_internal_trackerstatusesvector(int index) const
	{
		return _impl_.trackerstatusesvector_.Get(index);
	}

	inline const K2StatusPair& K2Message::trackerstatusesvector(int index) const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.trackerStatusesVector)
		return _internal_trackerstatusesvector(index);
	}

	inline K2StatusPair* K2Message::_internal_add_trackerstatusesvector()
	{
		return _impl_.trackerstatusesvector_.Add();
	}

	inline K2StatusPair* K2Message::add_trackerstatusesvector()
	{
		K2StatusPair* _add = _internal_add_trackerstatusesvector();
		// @@protoc_insertion_point(field_add:ktvr.K2Message.trackerStatusesVector)
		return _add;
	}

	inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<K2StatusPair>&
	K2Message::trackerstatusesvector() const
	{
		// @@protoc_insertion_point(field_list:ktvr.K2Message.trackerStatusesVector)
		return _impl_.trackerstatusesvector_;
	}

	// .ktvr.ITrackerType tracker = 6;
	inline void K2Message::clear_tracker()
	{
		_impl_.tracker_ = 0;
	}

	inline ITrackerType K2Message::_internal_tracker() const
	{
		return static_cast<ITrackerType>(_impl_.tracker_);
	}

	inline ITrackerType K2Message::tracker() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.tracker)
		return _internal_tracker();
	}

	inline void K2Message::_internal_set_tracker(ITrackerType value)
	{
		_impl_.tracker_ = value;
	}

	inline void K2Message::set_tracker(ITrackerType value)
	{
		_internal_set_tracker(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Message.tracker)
	}

	// bool state = 7;
	inline void K2Message::clear_state()
	{
		_impl_.state_ = false;
	}

	inline bool K2Message::_internal_state() const
	{
		return _impl_.state_;
	}

	inline bool K2Message::state() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.state)
		return _internal_state();
	}

	inline void K2Message::_internal_set_state(bool value)
	{
		_impl_.state_ = value;
	}

	inline void K2Message::set_state(bool value)
	{
		_internal_set_state(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Message.state)
	}

	// bool want_reply = 8;
	inline void K2Message::clear_want_reply()
	{
		_impl_.want_reply_ = false;
	}

	inline bool K2Message::_internal_want_reply() const
	{
		return _impl_.want_reply_;
	}

	inline bool K2Message::want_reply() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.want_reply)
		return _internal_want_reply();
	}

	inline void K2Message::_internal_set_want_reply(bool value)
	{
		_impl_.want_reply_ = value;
	}

	inline void K2Message::set_want_reply(bool value)
	{
		_internal_set_want_reply(value);
		// @@protoc_insertion_point(field_set:ktvr.K2Message.want_reply)
	}

	// string message_string = 9;
	inline void K2Message::clear_message_string()
	{
		_impl_.message_string_.ClearToEmpty();
	}

	inline const std::string& K2Message::message_string() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2Message.message_string)
		return _internal_message_string();
	}

	template <typename ArgT0, typename... ArgT>
	PROTOBUF_ALWAYS_INLINE
	void K2Message::set_message_string(ArgT0&& arg0, ArgT... args)
	{
		_impl_.message_string_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
		// @@protoc_insertion_point(field_set:ktvr.K2Message.message_string)
	}

	inline std::string* K2Message::mutable_message_string()
	{
		std::string* _s = _internal_mutable_message_string();
		// @@protoc_insertion_point(field_mutable:ktvr.K2Message.message_string)
		return _s;
	}

	inline const std::string& K2Message::_internal_message_string() const
	{
		return _impl_.message_string_.Get();
	}

	inline void K2Message::_internal_set_message_string(const std::string& value)
	{
		_impl_.message_string_.Set(value, GetArenaForAllocation());
	}

	inline std::string* K2Message::_internal_mutable_message_string()
	{
		return _impl_.message_string_.Mutable(GetArenaForAllocation());
	}

	inline std::string* K2Message::release_message_string()
	{
		// @@protoc_insertion_point(field_release:ktvr.K2Message.message_string)
		return _impl_.message_string_.Release();
	}

	inline void K2Message::set_allocated_message_string(std::string* message_string)
	{
		if (message_string != nullptr)
		{
		}
		else
		{
		}
		_impl_.message_string_.SetAllocated(message_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_string_.IsDefault()) {
    _impl_.message_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
		// @@protoc_insertion_point(field_set_allocated:ktvr.K2Message.message_string)
	}

	// -------------------------------------------------------------------

	// K2ResponseMessage

	// .ktvr.K2ResponseMessageType messageType = 1;
	inline void K2ResponseMessage::clear_messagetype()
	{
		_impl_.messagetype_ = 0;
	}

	inline K2ResponseMessageType K2ResponseMessage::_internal_messagetype() const
	{
		return static_cast<K2ResponseMessageType>(_impl_.messagetype_);
	}

	inline K2ResponseMessageType K2ResponseMessage::messagetype() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2ResponseMessage.messageType)
		return _internal_messagetype();
	}

	inline void K2ResponseMessage::_internal_set_messagetype(K2ResponseMessageType value)
	{
		_impl_.messagetype_ = value;
	}

	inline void K2ResponseMessage::set_messagetype(K2ResponseMessageType value)
	{
		_internal_set_messagetype(value);
		// @@protoc_insertion_point(field_set:ktvr.K2ResponseMessage.messageType)
	}

	// int64 messageTimestamp = 2;
	inline void K2ResponseMessage::clear_messagetimestamp()
	{
		_impl_.messagetimestamp_ = int64_t{0};
	}

	inline int64_t K2ResponseMessage::_internal_messagetimestamp() const
	{
		return _impl_.messagetimestamp_;
	}

	inline int64_t K2ResponseMessage::messagetimestamp() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2ResponseMessage.messageTimestamp)
		return _internal_messagetimestamp();
	}

	inline void K2ResponseMessage::_internal_set_messagetimestamp(int64_t value)
	{
		_impl_.messagetimestamp_ = value;
	}

	inline void K2ResponseMessage::set_messagetimestamp(int64_t value)
	{
		_internal_set_messagetimestamp(value);
		// @@protoc_insertion_point(field_set:ktvr.K2ResponseMessage.messageTimestamp)
	}

	// int64 messageManualTimestamp = 3;
	inline void K2ResponseMessage::clear_messagemanualtimestamp()
	{
		_impl_.messagemanualtimestamp_ = int64_t{0};
	}

	inline int64_t K2ResponseMessage::_internal_messagemanualtimestamp() const
	{
		return _impl_.messagemanualtimestamp_;
	}

	inline int64_t K2ResponseMessage::messagemanualtimestamp() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2ResponseMessage.messageManualTimestamp)
		return _internal_messagemanualtimestamp();
	}

	inline void K2ResponseMessage::_internal_set_messagemanualtimestamp(int64_t value)
	{
		_impl_.messagemanualtimestamp_ = value;
	}

	inline void K2ResponseMessage::set_messagemanualtimestamp(int64_t value)
	{
		_internal_set_messagemanualtimestamp(value);
		// @@protoc_insertion_point(field_set:ktvr.K2ResponseMessage.messageManualTimestamp)
	}

	// .ktvr.ITrackerType tracker = 4;
	inline void K2ResponseMessage::clear_tracker()
	{
		_impl_.tracker_ = 0;
	}

	inline ITrackerType K2ResponseMessage::_internal_tracker() const
	{
		return static_cast<ITrackerType>(_impl_.tracker_);
	}

	inline ITrackerType K2ResponseMessage::tracker() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2ResponseMessage.tracker)
		return _internal_tracker();
	}

	inline void K2ResponseMessage::_internal_set_tracker(ITrackerType value)
	{
		_impl_.tracker_ = value;
	}

	inline void K2ResponseMessage::set_tracker(ITrackerType value)
	{
		_internal_set_tracker(value);
		// @@protoc_insertion_point(field_set:ktvr.K2ResponseMessage.tracker)
	}

	// .ktvr.K2ResponseMessageCode result = 5;
	inline void K2ResponseMessage::clear_result()
	{
		_impl_.result_ = 0;
	}

	inline K2ResponseMessageCode K2ResponseMessage::_internal_result() const
	{
		return static_cast<K2ResponseMessageCode>(_impl_.result_);
	}

	inline K2ResponseMessageCode K2ResponseMessage::result() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2ResponseMessage.result)
		return _internal_result();
	}

	inline void K2ResponseMessage::_internal_set_result(K2ResponseMessageCode value)
	{
		_impl_.result_ = value;
	}

	inline void K2ResponseMessage::set_result(K2ResponseMessageCode value)
	{
		_internal_set_result(value);
		// @@protoc_insertion_point(field_set:ktvr.K2ResponseMessage.result)
	}

	// bool success = 6;
	inline void K2ResponseMessage::clear_success()
	{
		_impl_.success_ = false;
	}

	inline bool K2ResponseMessage::_internal_success() const
	{
		return _impl_.success_;
	}

	inline bool K2ResponseMessage::success() const
	{
		// @@protoc_insertion_point(field_get:ktvr.K2ResponseMessage.success)
		return _internal_success();
	}

	inline void K2ResponseMessage::_internal_set_success(bool value)
	{
		_impl_.success_ = value;
	}

	inline void K2ResponseMessage::set_success(bool value)
	{
		_internal_set_success(value);
		// @@protoc_insertion_point(field_set:ktvr.K2ResponseMessage.success)
	}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------

	// -------------------------------------------------------------------


	// @@protoc_insertion_point(namespace_scope)
} // namespace ktvr

PROTOBUF_NAMESPACE_OPEN
	template <>
	struct is_proto_enum<ktvr::ITrackerType> : std::true_type
	{
	};

	template <>
	inline const EnumDescriptor* GetEnumDescriptor<ktvr::ITrackerType>()
	{
		return ktvr::ITrackerType_descriptor();
	}

	template <>
	struct is_proto_enum<ktvr::K2MessageType> : std::true_type
	{
	};

	template <>
	inline const EnumDescriptor* GetEnumDescriptor<ktvr::K2MessageType>()
	{
		return ktvr::K2MessageType_descriptor();
	}

	template <>
	struct is_proto_enum<ktvr::K2ResponseMessageType> : std::true_type
	{
	};

	template <>
	inline const EnumDescriptor* GetEnumDescriptor<ktvr::K2ResponseMessageType>()
	{
		return ktvr::K2ResponseMessageType_descriptor();
	}

	template <>
	struct is_proto_enum<ktvr::K2ResponseMessageCode> : std::true_type
	{
	};

	template <>
	inline const EnumDescriptor* GetEnumDescriptor<ktvr::K2ResponseMessageCode>()
	{
		return ktvr::K2ResponseMessageCode_descriptor();
	}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Amethyst_5fAPI_2eproto
